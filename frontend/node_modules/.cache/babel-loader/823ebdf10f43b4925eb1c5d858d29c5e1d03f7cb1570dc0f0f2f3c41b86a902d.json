{"ast":null,"code":"import React from \"react\";\nimport ReactDOM from \"react-dom\";\nconst PUBLISH = 0;\nconst SUBSCRIBE = 1;\nconst RESET = 2;\nconst VALUE = 4;\nfunction compose(a, b) {\n  return arg => a(b(arg));\n}\nfunction thrush(arg, proc) {\n  return proc(arg);\n}\nfunction curry2to1(proc, arg1) {\n  return arg2 => proc(arg1, arg2);\n}\nfunction curry1to0(proc, arg) {\n  return () => proc(arg);\n}\nfunction tap(arg, proc) {\n  proc(arg);\n  return arg;\n}\nfunction tup() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  return args;\n}\nfunction call(proc) {\n  proc();\n}\nfunction always(value) {\n  return () => value;\n}\nfunction joinProc() {\n  for (var _len2 = arguments.length, procs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    procs[_key2] = arguments[_key2];\n  }\n  return () => {\n    procs.map(call);\n  };\n}\nfunction noop() {}\nfunction subscribe(emitter, subscription) {\n  return emitter(SUBSCRIBE, subscription);\n}\nfunction publish(publisher, value) {\n  publisher(PUBLISH, value);\n}\nfunction reset(emitter) {\n  emitter(RESET);\n}\nfunction getValue(depot) {\n  return depot(VALUE);\n}\nfunction connect(emitter, publisher) {\n  return subscribe(emitter, curry2to1(publisher, PUBLISH));\n}\nfunction handleNext(emitter, subscription) {\n  const unsub = emitter(SUBSCRIBE, value => {\n    unsub();\n    subscription(value);\n  });\n  return unsub;\n}\nfunction stream() {\n  const subscriptions = [];\n  return (action, arg) => {\n    switch (action) {\n      case RESET:\n        subscriptions.splice(0, subscriptions.length);\n        return;\n      case SUBSCRIBE:\n        subscriptions.push(arg);\n        return () => {\n          const indexOf = subscriptions.indexOf(arg);\n          if (indexOf > -1) {\n            subscriptions.splice(indexOf, 1);\n          }\n        };\n      case PUBLISH:\n        subscriptions.slice().forEach(subscription => {\n          subscription(arg);\n        });\n        return;\n      default:\n        throw new Error(`unrecognized action ${action}`);\n    }\n  };\n}\nfunction statefulStream(initial) {\n  let value = initial;\n  const innerSubject = stream();\n  return (action, arg) => {\n    switch (action) {\n      case SUBSCRIBE:\n        const subscription = arg;\n        subscription(value);\n        break;\n      case PUBLISH:\n        value = arg;\n        break;\n      case VALUE:\n        return value;\n    }\n    return innerSubject(action, arg);\n  };\n}\nfunction eventHandler(emitter) {\n  let unsub;\n  let currentSubscription;\n  const cleanup = () => unsub && unsub();\n  return function (action, subscription) {\n    switch (action) {\n      case SUBSCRIBE:\n        if (subscription) {\n          if (currentSubscription === subscription) {\n            return;\n          }\n          cleanup();\n          currentSubscription = subscription;\n          unsub = subscribe(emitter, subscription);\n          return unsub;\n        } else {\n          cleanup();\n          return noop;\n        }\n      case RESET:\n        cleanup();\n        currentSubscription = null;\n        return;\n      default:\n        throw new Error(`unrecognized action ${action}`);\n    }\n  };\n}\nfunction streamFromEmitter(emitter) {\n  return tap(stream(), stream2 => connect(emitter, stream2));\n}\nfunction statefulStreamFromEmitter(emitter, initial) {\n  return tap(statefulStream(initial), stream2 => connect(emitter, stream2));\n}\nfunction combineOperators() {\n  for (var _len3 = arguments.length, operators = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    operators[_key3] = arguments[_key3];\n  }\n  return subscriber => {\n    return operators.reduceRight(thrush, subscriber);\n  };\n}\nfunction pipe(source) {\n  for (var _len4 = arguments.length, operators = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n    operators[_key4 - 1] = arguments[_key4];\n  }\n  const project = combineOperators(...operators);\n  return (action, subscription) => {\n    switch (action) {\n      case SUBSCRIBE:\n        return subscribe(source, project(subscription));\n      case RESET:\n        reset(source);\n        return;\n    }\n  };\n}\nfunction defaultComparator(previous, next) {\n  return previous === next;\n}\nfunction distinctUntilChanged() {\n  let comparator = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultComparator;\n  let current;\n  return done => next => {\n    if (!comparator(current, next)) {\n      current = next;\n      done(next);\n    }\n  };\n}\nfunction filter(predicate) {\n  return done => value => {\n    predicate(value) && done(value);\n  };\n}\nfunction map(project) {\n  return done => compose(done, project);\n}\nfunction mapTo(value) {\n  return done => () => done(value);\n}\nfunction scan(scanner, initial) {\n  return done => value => done(initial = scanner(initial, value));\n}\nfunction skip(times) {\n  return done => value => {\n    times > 0 ? times-- : done(value);\n  };\n}\nfunction throttleTime(interval) {\n  let currentValue;\n  let timeout;\n  return done => value => {\n    currentValue = value;\n    if (timeout) {\n      return;\n    }\n    timeout = setTimeout(() => {\n      timeout = void 0;\n      done(currentValue);\n    }, interval);\n  };\n}\nfunction debounceTime(interval) {\n  let currentValue;\n  let timeout;\n  return done => value => {\n    currentValue = value;\n    if (timeout) {\n      clearTimeout(timeout);\n    }\n    timeout = setTimeout(() => {\n      done(currentValue);\n    }, interval);\n  };\n}\nfunction withLatestFrom() {\n  for (var _len5 = arguments.length, sources = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n    sources[_key5] = arguments[_key5];\n  }\n  const values = new Array(sources.length);\n  let called = 0;\n  let pendingCall = null;\n  const allCalled = Math.pow(2, sources.length) - 1;\n  sources.forEach((source, index) => {\n    const bit = Math.pow(2, index);\n    subscribe(source, value => {\n      const prevCalled = called;\n      called = called | bit;\n      values[index] = value;\n      if (prevCalled !== allCalled && called === allCalled && pendingCall) {\n        pendingCall();\n        pendingCall = null;\n      }\n    });\n  });\n  return done => value => {\n    const call2 = () => done([value].concat(values));\n    if (called === allCalled) {\n      call2();\n    } else {\n      pendingCall = call2;\n    }\n  };\n}\nfunction merge() {\n  for (var _len6 = arguments.length, sources = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n    sources[_key6] = arguments[_key6];\n  }\n  return function (action, subscription) {\n    switch (action) {\n      case SUBSCRIBE:\n        return joinProc(...sources.map(source => subscribe(source, subscription)));\n      case RESET:\n        return;\n      default:\n        throw new Error(`unrecognized action ${action}`);\n    }\n  };\n}\nfunction duc(source) {\n  let comparator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultComparator;\n  return pipe(source, distinctUntilChanged(comparator));\n}\nfunction combineLatest() {\n  const innerSubject = stream();\n  for (var _len7 = arguments.length, emitters = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n    emitters[_key7] = arguments[_key7];\n  }\n  const values = new Array(emitters.length);\n  let called = 0;\n  const allCalled = Math.pow(2, emitters.length) - 1;\n  emitters.forEach((source, index) => {\n    const bit = Math.pow(2, index);\n    subscribe(source, value => {\n      values[index] = value;\n      called = called | bit;\n      if (called === allCalled) {\n        publish(innerSubject, values);\n      }\n    });\n  });\n  return function (action, subscription) {\n    switch (action) {\n      case SUBSCRIBE:\n        if (called === allCalled) {\n          subscription(values);\n        }\n        return subscribe(innerSubject, subscription);\n      case RESET:\n        return reset(innerSubject);\n      default:\n        throw new Error(`unrecognized action ${action}`);\n    }\n  };\n}\nfunction system(constructor) {\n  let dependencies = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  let {\n    singleton\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n    singleton: true\n  };\n  return {\n    id: id(),\n    constructor,\n    dependencies,\n    singleton\n  };\n}\nconst id = () => Symbol();\nfunction init(systemSpec) {\n  const singletons = /* @__PURE__ */new Map();\n  const _init = _ref => {\n    let {\n      id: id2,\n      constructor,\n      dependencies,\n      singleton\n    } = _ref;\n    if (singleton && singletons.has(id2)) {\n      return singletons.get(id2);\n    }\n    const system2 = constructor(dependencies.map(e => _init(e)));\n    if (singleton) {\n      singletons.set(id2, system2);\n    }\n    return system2;\n  };\n  return _init(systemSpec);\n}\nfunction omit(keys, obj) {\n  const result = {};\n  const index = {};\n  let idx = 0;\n  const len = keys.length;\n  while (idx < len) {\n    index[keys[idx]] = 1;\n    idx += 1;\n  }\n  for (const prop in obj) {\n    if (!index.hasOwnProperty(prop)) {\n      result[prop] = obj[prop];\n    }\n  }\n  return result;\n}\nconst useIsomorphicLayoutEffect$2 = typeof document !== \"undefined\" ? React.useLayoutEffect : React.useEffect;\nfunction systemToComponent(systemSpec, map2, Root) {\n  const requiredPropNames = Object.keys(map2.required || {});\n  const optionalPropNames = Object.keys(map2.optional || {});\n  const methodNames = Object.keys(map2.methods || {});\n  const eventNames = Object.keys(map2.events || {});\n  const Context = React.createContext({});\n  function applyPropsToSystem(system2, props) {\n    if (system2[\"propsReady\"]) {\n      publish(system2[\"propsReady\"], false);\n    }\n    for (const requiredPropName of requiredPropNames) {\n      const stream2 = system2[map2.required[requiredPropName]];\n      publish(stream2, props[requiredPropName]);\n    }\n    for (const optionalPropName of optionalPropNames) {\n      if (optionalPropName in props) {\n        const stream2 = system2[map2.optional[optionalPropName]];\n        publish(stream2, props[optionalPropName]);\n      }\n    }\n    if (system2[\"propsReady\"]) {\n      publish(system2[\"propsReady\"], true);\n    }\n  }\n  function buildMethods(system2) {\n    return methodNames.reduce((acc, methodName) => {\n      acc[methodName] = value => {\n        const stream2 = system2[map2.methods[methodName]];\n        publish(stream2, value);\n      };\n      return acc;\n    }, {});\n  }\n  function buildEventHandlers(system2) {\n    return eventNames.reduce((handlers, eventName) => {\n      handlers[eventName] = eventHandler(system2[map2.events[eventName]]);\n      return handlers;\n    }, {});\n  }\n  const Component = React.forwardRef((propsWithChildren, ref) => {\n    const {\n      children,\n      ...props\n    } = propsWithChildren;\n    const [system2] = React.useState(() => {\n      return tap(init(systemSpec), system22 => applyPropsToSystem(system22, props));\n    });\n    const [handlers] = React.useState(curry1to0(buildEventHandlers, system2));\n    useIsomorphicLayoutEffect$2(() => {\n      for (const eventName of eventNames) {\n        if (eventName in props) {\n          subscribe(handlers[eventName], props[eventName]);\n        }\n      }\n      return () => {\n        Object.values(handlers).map(reset);\n      };\n    }, [props, handlers, system2]);\n    useIsomorphicLayoutEffect$2(() => {\n      applyPropsToSystem(system2, props);\n    });\n    React.useImperativeHandle(ref, always(buildMethods(system2)));\n    return React.createElement(Context.Provider, {\n      value: system2\n    }, Root ? React.createElement(Root, omit([...requiredPropNames, ...optionalPropNames, ...eventNames], props), children) : children);\n  });\n  const usePublisher2 = key => {\n    return React.useCallback(curry2to1(publish, React.useContext(Context)[key]), [key]);\n  };\n  const useEmitterValue2 = key => {\n    const system2 = React.useContext(Context);\n    const source = system2[key];\n    const [value, setValue] = React.useState(curry1to0(getValue, source));\n    useIsomorphicLayoutEffect$2(() => subscribe(source, next => {\n      if (next !== value) {\n        setValue(always(next));\n      }\n    }), [source, value]);\n    return value;\n  };\n  const useEmitter2 = (key, callback) => {\n    const context = React.useContext(Context);\n    const source = context[key];\n    useIsomorphicLayoutEffect$2(() => subscribe(source, callback), [callback, source]);\n  };\n  return {\n    Component,\n    usePublisher: usePublisher2,\n    useEmitterValue: useEmitterValue2,\n    useEmitter: useEmitter2\n  };\n}\nconst useIsomorphicLayoutEffect = typeof document !== \"undefined\" ? React.useLayoutEffect : React.useEffect;\nconst useIsomorphicLayoutEffect$1 = useIsomorphicLayoutEffect;\nvar LogLevel = /* @__PURE__ */(LogLevel2 => {\n  LogLevel2[LogLevel2[\"DEBUG\"] = 0] = \"DEBUG\";\n  LogLevel2[LogLevel2[\"INFO\"] = 1] = \"INFO\";\n  LogLevel2[LogLevel2[\"WARN\"] = 2] = \"WARN\";\n  LogLevel2[LogLevel2[\"ERROR\"] = 3] = \"ERROR\";\n  return LogLevel2;\n})(LogLevel || {});\nconst CONSOLE_METHOD_MAP = {\n  [0]: \"debug\",\n  [1]: \"log\",\n  [2]: \"warn\",\n  [3]: \"error\"\n};\nconst getGlobalThis = () => typeof globalThis === \"undefined\" ? window : globalThis;\nconst loggerSystem = system(() => {\n  const logLevel = statefulStream(3);\n  const log = statefulStream(function (label, message) {\n    let level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    const currentLevel = getGlobalThis()[\"VIRTUOSO_LOG_LEVEL\"] ?? getValue(logLevel);\n    if (level >= currentLevel) {\n      console[CONSOLE_METHOD_MAP[level]](\"%creact-virtuoso: %c%s %o\", \"color: #0253b3; font-weight: bold\", \"color: initial\", label, message);\n    }\n  });\n  return {\n    log,\n    logLevel\n  };\n}, [], {\n  singleton: true\n});\nfunction useSizeWithElRef(callback) {\n  let enabled = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  const ref = React.useRef(null);\n  let callbackRef = _el => {};\n  if (typeof ResizeObserver !== \"undefined\") {\n    const observer = new ResizeObserver(entries => {\n      const element = entries[0].target;\n      if (element.offsetParent !== null) {\n        callback(element);\n      }\n    });\n    callbackRef = elRef => {\n      if (elRef && enabled) {\n        observer.observe(elRef);\n        ref.current = elRef;\n      } else {\n        if (ref.current) {\n          observer.unobserve(ref.current);\n        }\n        ref.current = null;\n      }\n    };\n  }\n  return {\n    ref,\n    callbackRef\n  };\n}\nfunction useSize(callback) {\n  let enabled = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  return useSizeWithElRef(callback, enabled).callbackRef;\n}\nfunction useChangedListContentsSizes(callback, itemSize, enabled, scrollContainerStateCallback, log, gap, customScrollParent) {\n  return useSizeWithElRef(el => {\n    const ranges = getChangedChildSizes(el.children, itemSize, \"offsetHeight\", log);\n    let scrollableElement = el.parentElement;\n    while (!scrollableElement.dataset[\"virtuosoScroller\"]) {\n      scrollableElement = scrollableElement.parentElement;\n    }\n    const windowScrolling = scrollableElement.lastElementChild.dataset[\"viewportType\"] === \"window\";\n    const scrollTop = customScrollParent ? customScrollParent.scrollTop : windowScrolling ? window.pageYOffset || document.documentElement.scrollTop : scrollableElement.scrollTop;\n    const scrollHeight = customScrollParent ? customScrollParent.scrollHeight : windowScrolling ? document.documentElement.scrollHeight : scrollableElement.scrollHeight;\n    const viewportHeight = customScrollParent ? customScrollParent.offsetHeight : windowScrolling ? window.innerHeight : scrollableElement.offsetHeight;\n    scrollContainerStateCallback({\n      scrollTop: Math.max(scrollTop, 0),\n      scrollHeight,\n      viewportHeight\n    });\n    gap == null ? void 0 : gap(resolveGapValue$1(\"row-gap\", getComputedStyle(el).rowGap, log));\n    if (ranges !== null) {\n      callback(ranges);\n    }\n  }, enabled);\n}\nfunction getChangedChildSizes(children, itemSize, field, log) {\n  const length = children.length;\n  if (length === 0) {\n    return null;\n  }\n  const results = [];\n  for (let i = 0; i < length; i++) {\n    const child = children.item(i);\n    if (!child || child.dataset.index === void 0) {\n      continue;\n    }\n    const index = parseInt(child.dataset.index);\n    const knownSize = parseFloat(child.dataset.knownSize);\n    const size = itemSize(child, field);\n    if (size === 0) {\n      log(\"Zero-sized element, this should not happen\", {\n        child\n      }, LogLevel.ERROR);\n    }\n    if (size === knownSize) {\n      continue;\n    }\n    const lastResult = results[results.length - 1];\n    if (results.length === 0 || lastResult.size !== size || lastResult.endIndex !== index - 1) {\n      results.push({\n        startIndex: index,\n        endIndex: index,\n        size\n      });\n    } else {\n      results[results.length - 1].endIndex++;\n    }\n  }\n  return results;\n}\nfunction resolveGapValue$1(property, value, log) {\n  if (value !== \"normal\" && !(value == null ? void 0 : value.endsWith(\"px\"))) {\n    log(`${property} was not resolved to pixel value correctly`, value, LogLevel.WARN);\n  }\n  if (value === \"normal\") {\n    return 0;\n  }\n  return parseInt(value ?? \"0\", 10);\n}\nfunction correctItemSize(el, dimension) {\n  return Math.round(el.getBoundingClientRect()[dimension]);\n}\nfunction approximatelyEqual(num1, num2) {\n  return Math.abs(num1 - num2) < 1.01;\n}\nfunction useScrollTop(scrollContainerStateCallback, smoothScrollTargetReached, scrollerElement) {\n  let scrollerRefCallback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : noop;\n  let customScrollParent = arguments.length > 4 ? arguments[4] : undefined;\n  const scrollerRef = React.useRef(null);\n  const scrollTopTarget = React.useRef(null);\n  const timeoutRef = React.useRef(null);\n  const handler = React.useCallback(ev => {\n    const el = ev.target;\n    const windowScroll = el === window || el === document;\n    const scrollTop = windowScroll ? window.pageYOffset || document.documentElement.scrollTop : el.scrollTop;\n    const scrollHeight = windowScroll ? document.documentElement.scrollHeight : el.scrollHeight;\n    const viewportHeight = windowScroll ? window.innerHeight : el.offsetHeight;\n    const call2 = () => {\n      scrollContainerStateCallback({\n        scrollTop: Math.max(scrollTop, 0),\n        scrollHeight,\n        viewportHeight\n      });\n    };\n    if (ev.suppressFlushSync) {\n      call2();\n    } else {\n      ReactDOM.flushSync(call2);\n    }\n    if (scrollTopTarget.current !== null) {\n      if (scrollTop === scrollTopTarget.current || scrollTop <= 0 || scrollTop === scrollHeight - viewportHeight) {\n        scrollTopTarget.current = null;\n        smoothScrollTargetReached(true);\n        if (timeoutRef.current) {\n          clearTimeout(timeoutRef.current);\n          timeoutRef.current = null;\n        }\n      }\n    }\n  }, [scrollContainerStateCallback, smoothScrollTargetReached]);\n  React.useEffect(() => {\n    const localRef = customScrollParent ? customScrollParent : scrollerRef.current;\n    scrollerRefCallback(customScrollParent ? customScrollParent : scrollerRef.current);\n    handler({\n      target: localRef,\n      suppressFlushSync: true\n    });\n    localRef.addEventListener(\"scroll\", handler, {\n      passive: true\n    });\n    return () => {\n      scrollerRefCallback(null);\n      localRef.removeEventListener(\"scroll\", handler);\n    };\n  }, [scrollerRef, handler, scrollerElement, scrollerRefCallback, customScrollParent]);\n  function scrollToCallback(location) {\n    const scrollerElement2 = scrollerRef.current;\n    if (!scrollerElement2 || \"offsetHeight\" in scrollerElement2 && scrollerElement2.offsetHeight === 0) {\n      return;\n    }\n    const isSmooth = location.behavior === \"smooth\";\n    let offsetHeight;\n    let scrollHeight;\n    let scrollTop;\n    if (scrollerElement2 === window) {\n      scrollHeight = Math.max(correctItemSize(document.documentElement, \"height\"), document.documentElement.scrollHeight);\n      offsetHeight = window.innerHeight;\n      scrollTop = document.documentElement.scrollTop;\n    } else {\n      scrollHeight = scrollerElement2.scrollHeight;\n      offsetHeight = correctItemSize(scrollerElement2, \"height\");\n      scrollTop = scrollerElement2.scrollTop;\n    }\n    const maxScrollTop = scrollHeight - offsetHeight;\n    location.top = Math.ceil(Math.max(Math.min(maxScrollTop, location.top), 0));\n    if (approximatelyEqual(offsetHeight, scrollHeight) || location.top === scrollTop) {\n      scrollContainerStateCallback({\n        scrollTop,\n        scrollHeight,\n        viewportHeight: offsetHeight\n      });\n      if (isSmooth) {\n        smoothScrollTargetReached(true);\n      }\n      return;\n    }\n    if (isSmooth) {\n      scrollTopTarget.current = location.top;\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n      }\n      timeoutRef.current = setTimeout(() => {\n        timeoutRef.current = null;\n        scrollTopTarget.current = null;\n        smoothScrollTargetReached(true);\n      }, 1e3);\n    } else {\n      scrollTopTarget.current = null;\n    }\n    scrollerElement2.scrollTo(location);\n  }\n  function scrollByCallback(location) {\n    scrollerRef.current.scrollBy(location);\n  }\n  return {\n    scrollerRef,\n    scrollByCallback,\n    scrollToCallback\n  };\n}\nconst domIOSystem = system(() => {\n  const scrollContainerState = stream();\n  const scrollTop = stream();\n  const deviation = statefulStream(0);\n  const smoothScrollTargetReached = stream();\n  const statefulScrollTop = statefulStream(0);\n  const viewportHeight = stream();\n  const scrollHeight = stream();\n  const headerHeight = statefulStream(0);\n  const fixedHeaderHeight = statefulStream(0);\n  const fixedFooterHeight = statefulStream(0);\n  const footerHeight = statefulStream(0);\n  const scrollTo = stream();\n  const scrollBy = stream();\n  const scrollingInProgress = statefulStream(false);\n  connect(pipe(scrollContainerState, map(_ref2 => {\n    let {\n      scrollTop: scrollTop2\n    } = _ref2;\n    return scrollTop2;\n  })), scrollTop);\n  connect(pipe(scrollContainerState, map(_ref3 => {\n    let {\n      scrollHeight: scrollHeight2\n    } = _ref3;\n    return scrollHeight2;\n  })), scrollHeight);\n  connect(scrollTop, statefulScrollTop);\n  return {\n    scrollContainerState,\n    scrollTop,\n    viewportHeight,\n    headerHeight,\n    fixedHeaderHeight,\n    fixedFooterHeight,\n    footerHeight,\n    scrollHeight,\n    smoothScrollTargetReached,\n    scrollTo,\n    scrollBy,\n    statefulScrollTop,\n    deviation,\n    scrollingInProgress\n  };\n}, [], {\n  singleton: true\n});\nconst NIL_NODE = {\n  lvl: 0\n};\nfunction newAANode(k, v, lvl) {\n  let l = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : NIL_NODE;\n  let r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : NIL_NODE;\n  return {\n    k,\n    v,\n    lvl,\n    l,\n    r\n  };\n}\nfunction empty(node) {\n  return node === NIL_NODE;\n}\nfunction newTree() {\n  return NIL_NODE;\n}\nfunction remove(node, key) {\n  if (empty(node)) return NIL_NODE;\n  const {\n    k,\n    l,\n    r\n  } = node;\n  if (key === k) {\n    if (empty(l)) {\n      return r;\n    } else if (empty(r)) {\n      return l;\n    } else {\n      const [lastKey, lastValue] = last(l);\n      return adjust(clone(node, {\n        k: lastKey,\n        v: lastValue,\n        l: deleteLast(l)\n      }));\n    }\n  } else if (key < k) {\n    return adjust(clone(node, {\n      l: remove(l, key)\n    }));\n  } else {\n    return adjust(clone(node, {\n      r: remove(r, key)\n    }));\n  }\n}\nfunction findMaxKeyValue(node, value) {\n  let field = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"k\";\n  if (empty(node)) {\n    return [-Infinity, void 0];\n  }\n  if (node[field] === value) {\n    return [node.k, node.v];\n  }\n  if (node[field] < value) {\n    const r = findMaxKeyValue(node.r, value, field);\n    if (r[0] === -Infinity) {\n      return [node.k, node.v];\n    } else {\n      return r;\n    }\n  }\n  return findMaxKeyValue(node.l, value, field);\n}\nfunction insert(node, k, v) {\n  if (empty(node)) {\n    return newAANode(k, v, 1);\n  }\n  if (k === node.k) {\n    return clone(node, {\n      k,\n      v\n    });\n  } else if (k < node.k) {\n    return rebalance(clone(node, {\n      l: insert(node.l, k, v)\n    }));\n  } else {\n    return rebalance(clone(node, {\n      r: insert(node.r, k, v)\n    }));\n  }\n}\nfunction walkWithin(node, start, end) {\n  if (empty(node)) {\n    return [];\n  }\n  const {\n    k,\n    v,\n    l,\n    r\n  } = node;\n  let result = [];\n  if (k > start) {\n    result = result.concat(walkWithin(l, start, end));\n  }\n  if (k >= start && k <= end) {\n    result.push({\n      k,\n      v\n    });\n  }\n  if (k <= end) {\n    result = result.concat(walkWithin(r, start, end));\n  }\n  return result;\n}\nfunction walk(node) {\n  if (empty(node)) {\n    return [];\n  }\n  return [...walk(node.l), {\n    k: node.k,\n    v: node.v\n  }, ...walk(node.r)];\n}\nfunction last(node) {\n  return empty(node.r) ? [node.k, node.v] : last(node.r);\n}\nfunction deleteLast(node) {\n  return empty(node.r) ? node.l : adjust(clone(node, {\n    r: deleteLast(node.r)\n  }));\n}\nfunction clone(node, args) {\n  return newAANode(args.k !== void 0 ? args.k : node.k, args.v !== void 0 ? args.v : node.v, args.lvl !== void 0 ? args.lvl : node.lvl, args.l !== void 0 ? args.l : node.l, args.r !== void 0 ? args.r : node.r);\n}\nfunction isSingle(node) {\n  return empty(node) || node.lvl > node.r.lvl;\n}\nfunction rebalance(node) {\n  return split(skew(node));\n}\nfunction adjust(node) {\n  const {\n    l,\n    r,\n    lvl\n  } = node;\n  if (r.lvl >= lvl - 1 && l.lvl >= lvl - 1) {\n    return node;\n  } else if (lvl > r.lvl + 1) {\n    if (isSingle(l)) {\n      return skew(clone(node, {\n        lvl: lvl - 1\n      }));\n    } else {\n      if (!empty(l) && !empty(l.r)) {\n        return clone(l.r, {\n          l: clone(l, {\n            r: l.r.l\n          }),\n          r: clone(node, {\n            l: l.r.r,\n            lvl: lvl - 1\n          }),\n          lvl\n        });\n      } else {\n        throw new Error(\"Unexpected empty nodes\");\n      }\n    }\n  } else {\n    if (isSingle(node)) {\n      return split(clone(node, {\n        lvl: lvl - 1\n      }));\n    } else {\n      if (!empty(r) && !empty(r.l)) {\n        const rl = r.l;\n        const rlvl = isSingle(rl) ? r.lvl - 1 : r.lvl;\n        return clone(rl, {\n          l: clone(node, {\n            r: rl.l,\n            lvl: lvl - 1\n          }),\n          r: split(clone(r, {\n            l: rl.r,\n            lvl: rlvl\n          })),\n          lvl: rl.lvl + 1\n        });\n      } else {\n        throw new Error(\"Unexpected empty nodes\");\n      }\n    }\n  }\n}\nfunction rangesWithin(node, startIndex, endIndex) {\n  if (empty(node)) {\n    return [];\n  }\n  const adjustedStart = findMaxKeyValue(node, startIndex)[0];\n  return toRanges(walkWithin(node, adjustedStart, endIndex));\n}\nfunction arrayToRanges(items, parser) {\n  const length = items.length;\n  if (length === 0) {\n    return [];\n  }\n  let {\n    index: start,\n    value\n  } = parser(items[0]);\n  const result = [];\n  for (let i = 1; i < length; i++) {\n    const {\n      index: nextIndex,\n      value: nextValue\n    } = parser(items[i]);\n    result.push({\n      start,\n      end: nextIndex - 1,\n      value\n    });\n    start = nextIndex;\n    value = nextValue;\n  }\n  result.push({\n    start,\n    end: Infinity,\n    value\n  });\n  return result;\n}\nfunction toRanges(nodes) {\n  return arrayToRanges(nodes, _ref4 => {\n    let {\n      k: index,\n      v: value\n    } = _ref4;\n    return {\n      index,\n      value\n    };\n  });\n}\nfunction split(node) {\n  const {\n    r,\n    lvl\n  } = node;\n  return !empty(r) && !empty(r.r) && r.lvl === lvl && r.r.lvl === lvl ? clone(r, {\n    l: clone(node, {\n      r: r.l\n    }),\n    lvl: lvl + 1\n  }) : node;\n}\nfunction skew(node) {\n  const {\n    l\n  } = node;\n  return !empty(l) && l.lvl === node.lvl ? clone(l, {\n    r: clone(node, {\n      l: l.r\n    })\n  }) : node;\n}\nfunction findIndexOfClosestSmallerOrEqual(items, value, comparator) {\n  let start = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  let end = items.length - 1;\n  while (start <= end) {\n    const index = Math.floor((start + end) / 2);\n    const item = items[index];\n    const match = comparator(item, value);\n    if (match === 0) {\n      return index;\n    }\n    if (match === -1) {\n      if (end - start < 2) {\n        return index - 1;\n      }\n      end = index - 1;\n    } else {\n      if (end === start) {\n        return index;\n      }\n      start = index + 1;\n    }\n  }\n  throw new Error(`Failed binary finding record in array - ${items.join(\",\")}, searched for ${value}`);\n}\nfunction findClosestSmallerOrEqual(items, value, comparator) {\n  return items[findIndexOfClosestSmallerOrEqual(items, value, comparator)];\n}\nfunction findRange(items, startValue, endValue, comparator) {\n  const startIndex = findIndexOfClosestSmallerOrEqual(items, startValue, comparator);\n  const endIndex = findIndexOfClosestSmallerOrEqual(items, endValue, comparator, startIndex);\n  return items.slice(startIndex, endIndex + 1);\n}\nconst recalcSystem = system(() => {\n  const recalcInProgress = statefulStream(false);\n  return {\n    recalcInProgress\n  };\n}, [], {\n  singleton: true\n});\nfunction rangeIncludes(refRange) {\n  const {\n    size,\n    startIndex,\n    endIndex\n  } = refRange;\n  return range => {\n    return range.start === startIndex && (range.end === endIndex || range.end === Infinity) && range.value === size;\n  };\n}\nfunction insertRanges(sizeTree, ranges) {\n  let syncStart = empty(sizeTree) ? 0 : Infinity;\n  for (const range of ranges) {\n    const {\n      size,\n      startIndex,\n      endIndex\n    } = range;\n    syncStart = Math.min(syncStart, startIndex);\n    if (empty(sizeTree)) {\n      sizeTree = insert(sizeTree, 0, size);\n      continue;\n    }\n    const overlappingRanges = rangesWithin(sizeTree, startIndex - 1, endIndex + 1);\n    if (overlappingRanges.some(rangeIncludes(range))) {\n      continue;\n    }\n    let firstPassDone = false;\n    let shouldInsert = false;\n    for (const {\n      start: rangeStart,\n      end: rangeEnd,\n      value: rangeValue\n    } of overlappingRanges) {\n      if (!firstPassDone) {\n        shouldInsert = rangeValue !== size;\n        firstPassDone = true;\n      } else {\n        if (endIndex >= rangeStart || size === rangeValue) {\n          sizeTree = remove(sizeTree, rangeStart);\n        }\n      }\n      if (rangeEnd > endIndex && endIndex >= rangeStart) {\n        if (rangeValue !== size) {\n          sizeTree = insert(sizeTree, endIndex + 1, rangeValue);\n        }\n      }\n    }\n    if (shouldInsert) {\n      sizeTree = insert(sizeTree, startIndex, size);\n    }\n  }\n  return [sizeTree, syncStart];\n}\nfunction initialSizeState() {\n  return {\n    offsetTree: [],\n    sizeTree: newTree(),\n    groupOffsetTree: newTree(),\n    lastIndex: 0,\n    lastOffset: 0,\n    lastSize: 0,\n    groupIndices: []\n  };\n}\nfunction indexComparator(_ref5, index) {\n  let {\n    index: itemIndex\n  } = _ref5;\n  return index === itemIndex ? 0 : index < itemIndex ? -1 : 1;\n}\nfunction offsetComparator(_ref6, offset) {\n  let {\n    offset: itemOffset\n  } = _ref6;\n  return offset === itemOffset ? 0 : offset < itemOffset ? -1 : 1;\n}\nfunction offsetPointParser(point) {\n  return {\n    index: point.index,\n    value: point\n  };\n}\nfunction rangesWithinOffsets(tree, startOffset, endOffset) {\n  let minStartIndex = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  if (minStartIndex > 0) {\n    startOffset = Math.max(startOffset, findClosestSmallerOrEqual(tree, minStartIndex, indexComparator).offset);\n  }\n  return arrayToRanges(findRange(tree, startOffset, endOffset, offsetComparator), offsetPointParser);\n}\nfunction createOffsetTree(prevOffsetTree, syncStart, sizeTree, gap) {\n  let offsetTree = prevOffsetTree;\n  let prevIndex = 0;\n  let prevSize = 0;\n  let prevOffset = 0;\n  let startIndex = 0;\n  if (syncStart !== 0) {\n    startIndex = findIndexOfClosestSmallerOrEqual(offsetTree, syncStart - 1, indexComparator);\n    const offsetInfo = offsetTree[startIndex];\n    prevOffset = offsetInfo.offset;\n    const kv = findMaxKeyValue(sizeTree, syncStart - 1);\n    prevIndex = kv[0];\n    prevSize = kv[1];\n    if (offsetTree.length && offsetTree[startIndex].size === findMaxKeyValue(sizeTree, syncStart)[1]) {\n      startIndex -= 1;\n    }\n    offsetTree = offsetTree.slice(0, startIndex + 1);\n  } else {\n    offsetTree = [];\n  }\n  for (const {\n    start: startIndex2,\n    value\n  } of rangesWithin(sizeTree, syncStart, Infinity)) {\n    const indexOffset = startIndex2 - prevIndex;\n    const aOffset = indexOffset * prevSize + prevOffset + indexOffset * gap;\n    offsetTree.push({\n      offset: aOffset,\n      size: value,\n      index: startIndex2\n    });\n    prevIndex = startIndex2;\n    prevOffset = aOffset;\n    prevSize = value;\n  }\n  return {\n    offsetTree,\n    lastIndex: prevIndex,\n    lastOffset: prevOffset,\n    lastSize: prevSize\n  };\n}\nfunction sizeStateReducer(state, _ref7) {\n  let [ranges, groupIndices, log, gap] = _ref7;\n  if (ranges.length > 0) {\n    log(\"received item sizes\", ranges, LogLevel.DEBUG);\n  }\n  const sizeTree = state.sizeTree;\n  let newSizeTree = sizeTree;\n  let syncStart = 0;\n  if (groupIndices.length > 0 && empty(sizeTree) && ranges.length === 2) {\n    const groupSize = ranges[0].size;\n    const itemSize = ranges[1].size;\n    newSizeTree = groupIndices.reduce((tree, groupIndex) => {\n      return insert(insert(tree, groupIndex, groupSize), groupIndex + 1, itemSize);\n    }, newSizeTree);\n  } else {\n    [newSizeTree, syncStart] = insertRanges(newSizeTree, ranges);\n  }\n  if (newSizeTree === sizeTree) {\n    return state;\n  }\n  const {\n    offsetTree: newOffsetTree,\n    lastIndex,\n    lastSize,\n    lastOffset\n  } = createOffsetTree(state.offsetTree, syncStart, newSizeTree, gap);\n  return {\n    sizeTree: newSizeTree,\n    offsetTree: newOffsetTree,\n    lastIndex,\n    lastOffset,\n    lastSize,\n    groupOffsetTree: groupIndices.reduce((tree, index) => {\n      return insert(tree, index, offsetOf(index, newOffsetTree, gap));\n    }, newTree()),\n    groupIndices\n  };\n}\nfunction offsetOf(index, tree, gap) {\n  if (tree.length === 0) {\n    return 0;\n  }\n  const {\n    offset,\n    index: startIndex,\n    size\n  } = findClosestSmallerOrEqual(tree, index, indexComparator);\n  const itemCount = index - startIndex;\n  const top = size * itemCount + (itemCount - 1) * gap + offset;\n  return top > 0 ? top + gap : top;\n}\nfunction isGroupLocation(location) {\n  return typeof location.groupIndex !== \"undefined\";\n}\nfunction originalIndexFromLocation(location, sizes, lastIndex) {\n  if (isGroupLocation(location)) {\n    return sizes.groupIndices[location.groupIndex] + 1;\n  } else {\n    const numericIndex = location.index === \"LAST\" ? lastIndex : location.index;\n    let result = originalIndexFromItemIndex(numericIndex, sizes);\n    result = Math.max(0, result, Math.min(lastIndex, result));\n    return result;\n  }\n}\nfunction originalIndexFromItemIndex(itemIndex, sizes) {\n  if (!hasGroups(sizes)) {\n    return itemIndex;\n  }\n  let groupOffset = 0;\n  while (sizes.groupIndices[groupOffset] <= itemIndex + groupOffset) {\n    groupOffset++;\n  }\n  return itemIndex + groupOffset;\n}\nfunction hasGroups(sizes) {\n  return !empty(sizes.groupOffsetTree);\n}\nconst SIZE_MAP = {\n  offsetHeight: \"height\",\n  offsetWidth: \"width\"\n};\nconst sizeSystem = system(_ref8 => {\n  let [{\n    log\n  }, {\n    recalcInProgress\n  }] = _ref8;\n  const sizeRanges = stream();\n  const totalCount = stream();\n  const statefulTotalCount = statefulStreamFromEmitter(totalCount, 0);\n  const unshiftWith = stream();\n  const shiftWith = stream();\n  const firstItemIndex = statefulStream(0);\n  const groupIndices = statefulStream([]);\n  const fixedItemSize = statefulStream(void 0);\n  const defaultItemSize = statefulStream(void 0);\n  const itemSize = statefulStream((el, field) => correctItemSize(el, SIZE_MAP[field]));\n  const data = statefulStream(void 0);\n  const gap = statefulStream(0);\n  const initial = initialSizeState();\n  const sizes = statefulStreamFromEmitter(pipe(sizeRanges, withLatestFrom(groupIndices, log, gap), scan(sizeStateReducer, initial), distinctUntilChanged()), initial);\n  connect(pipe(groupIndices, filter(indexes => indexes.length > 0), withLatestFrom(sizes, gap), map(_ref9 => {\n    let [groupIndices2, sizes2, gap2] = _ref9;\n    const groupOffsetTree = groupIndices2.reduce((tree, index, idx) => {\n      return insert(tree, index, offsetOf(index, sizes2.offsetTree, gap2) || idx);\n    }, newTree());\n    return {\n      ...sizes2,\n      groupIndices: groupIndices2,\n      groupOffsetTree\n    };\n  })), sizes);\n  connect(pipe(totalCount, withLatestFrom(sizes), filter(_ref10 => {\n    let [totalCount2, {\n      lastIndex\n    }] = _ref10;\n    return totalCount2 < lastIndex;\n  }), map(_ref11 => {\n    let [totalCount2, {\n      lastIndex,\n      lastSize\n    }] = _ref11;\n    return [{\n      startIndex: totalCount2,\n      endIndex: lastIndex,\n      size: lastSize\n    }];\n  })), sizeRanges);\n  connect(fixedItemSize, defaultItemSize);\n  const trackItemSizes = statefulStreamFromEmitter(pipe(fixedItemSize, map(size => size === void 0)), true);\n  connect(pipe(defaultItemSize, filter(value => {\n    return value !== void 0 && empty(getValue(sizes).sizeTree);\n  }), map(size => [{\n    startIndex: 0,\n    endIndex: 0,\n    size\n  }])), sizeRanges);\n  const listRefresh = streamFromEmitter(pipe(sizeRanges, withLatestFrom(sizes), scan((_ref12, _ref13) => {\n    let {\n      sizes: oldSizes\n    } = _ref12;\n    let [_, newSizes] = _ref13;\n    return {\n      changed: newSizes !== oldSizes,\n      sizes: newSizes\n    };\n  }, {\n    changed: false,\n    sizes: initial\n  }), map(value => value.changed)));\n  subscribe(pipe(firstItemIndex, scan((prev, next) => {\n    return {\n      diff: prev.prev - next,\n      prev: next\n    };\n  }, {\n    diff: 0,\n    prev: 0\n  }), map(val => val.diff)), offset => {\n    if (offset > 0) {\n      publish(recalcInProgress, true);\n      publish(unshiftWith, offset);\n    } else if (offset < 0) {\n      publish(shiftWith, offset);\n    }\n  });\n  subscribe(pipe(firstItemIndex, withLatestFrom(log)), _ref14 => {\n    let [index, log2] = _ref14;\n    if (index < 0) {\n      log2(\"`firstItemIndex` prop should not be set to less than zero. If you don't know the total count, just use a very high value\", {\n        firstItemIndex\n      }, LogLevel.ERROR);\n    }\n  });\n  const beforeUnshiftWith = streamFromEmitter(unshiftWith);\n  connect(pipe(unshiftWith, withLatestFrom(sizes), map(_ref15 => {\n    let [unshiftWith2, sizes2] = _ref15;\n    if (sizes2.groupIndices.length > 0) {\n      throw new Error(\"Virtuoso: prepending items does not work with groups\");\n    }\n    return walk(sizes2.sizeTree).reduce((acc, _ref16) => {\n      let {\n        k: index,\n        v: size\n      } = _ref16;\n      return {\n        ranges: [...acc.ranges, {\n          startIndex: acc.prevIndex,\n          endIndex: index + unshiftWith2 - 1,\n          size: acc.prevSize\n        }],\n        prevIndex: index + unshiftWith2,\n        prevSize: size\n      };\n    }, {\n      ranges: [],\n      prevIndex: 0,\n      prevSize: sizes2.lastSize\n    }).ranges;\n  })), sizeRanges);\n  const shiftWithOffset = streamFromEmitter(pipe(shiftWith, withLatestFrom(sizes, gap), map(_ref17 => {\n    let [shiftWith2, {\n      offsetTree\n    }, gap2] = _ref17;\n    const newFirstItemIndex = -shiftWith2;\n    return offsetOf(newFirstItemIndex, offsetTree, gap2);\n  })));\n  connect(pipe(shiftWith, withLatestFrom(sizes, gap), map(_ref18 => {\n    let [shiftWith2, sizes2, gap2] = _ref18;\n    if (sizes2.groupIndices.length > 0) {\n      throw new Error(\"Virtuoso: shifting items does not work with groups\");\n    }\n    const newSizeTree = walk(sizes2.sizeTree).reduce((acc, _ref19) => {\n      let {\n        k,\n        v\n      } = _ref19;\n      return insert(acc, Math.max(0, k + shiftWith2), v);\n    }, newTree());\n    return {\n      ...sizes2,\n      sizeTree: newSizeTree,\n      ...createOffsetTree(sizes2.offsetTree, 0, newSizeTree, gap2)\n    };\n  })), sizes);\n  return {\n    data,\n    totalCount,\n    sizeRanges,\n    groupIndices,\n    defaultItemSize,\n    fixedItemSize,\n    unshiftWith,\n    shiftWith,\n    shiftWithOffset,\n    beforeUnshiftWith,\n    firstItemIndex,\n    gap,\n    sizes,\n    listRefresh,\n    statefulTotalCount,\n    trackItemSizes,\n    itemSize\n  };\n}, tup(loggerSystem, recalcSystem), {\n  singleton: true\n});\nconst SUPPORTS_SCROLL_TO_OPTIONS = typeof document !== \"undefined\" && \"scrollBehavior\" in document.documentElement.style;\nfunction normalizeIndexLocation(location) {\n  const result = typeof location === \"number\" ? {\n    index: location\n  } : location;\n  if (!result.align) {\n    result.align = \"start\";\n  }\n  if (!result.behavior || !SUPPORTS_SCROLL_TO_OPTIONS) {\n    result.behavior = \"auto\";\n  }\n  if (!result.offset) {\n    result.offset = 0;\n  }\n  return result;\n}\nconst scrollToIndexSystem = system(_ref20 => {\n  let [{\n    sizes,\n    totalCount,\n    listRefresh,\n    gap\n  }, {\n    scrollingInProgress,\n    viewportHeight,\n    scrollTo,\n    smoothScrollTargetReached,\n    headerHeight,\n    footerHeight,\n    fixedHeaderHeight,\n    fixedFooterHeight\n  }, {\n    log\n  }] = _ref20;\n  const scrollToIndex = stream();\n  const topListHeight = statefulStream(0);\n  let unsubscribeNextListRefresh = null;\n  let cleartTimeoutRef = null;\n  let unsubscribeListRefresh = null;\n  function cleanup() {\n    if (unsubscribeNextListRefresh) {\n      unsubscribeNextListRefresh();\n      unsubscribeNextListRefresh = null;\n    }\n    if (unsubscribeListRefresh) {\n      unsubscribeListRefresh();\n      unsubscribeListRefresh = null;\n    }\n    if (cleartTimeoutRef) {\n      clearTimeout(cleartTimeoutRef);\n      cleartTimeoutRef = null;\n    }\n    publish(scrollingInProgress, false);\n  }\n  connect(pipe(scrollToIndex, withLatestFrom(sizes, viewportHeight, totalCount, topListHeight, headerHeight, footerHeight, log), withLatestFrom(gap, fixedHeaderHeight, fixedFooterHeight), map(_ref21 => {\n    let [[location, sizes2, viewportHeight2, totalCount2, topListHeight2, headerHeight2, footerHeight2, log2], gap2, fixedHeaderHeight2, fixedFooterHeight2] = _ref21;\n    const normalLocation = normalizeIndexLocation(location);\n    const {\n      align,\n      behavior,\n      offset\n    } = normalLocation;\n    const lastIndex = totalCount2 - 1;\n    const index = originalIndexFromLocation(normalLocation, sizes2, lastIndex);\n    let top = offsetOf(index, sizes2.offsetTree, gap2) + headerHeight2;\n    if (align === \"end\") {\n      top += fixedHeaderHeight2 + findMaxKeyValue(sizes2.sizeTree, index)[1] - viewportHeight2 + fixedFooterHeight2;\n      if (index === lastIndex) {\n        top += footerHeight2;\n      }\n    } else if (align === \"center\") {\n      top += (fixedHeaderHeight2 + findMaxKeyValue(sizes2.sizeTree, index)[1] - viewportHeight2 + fixedFooterHeight2) / 2;\n    } else {\n      top -= topListHeight2;\n    }\n    if (offset) {\n      top += offset;\n    }\n    const retry = listChanged => {\n      cleanup();\n      if (listChanged) {\n        log2(\"retrying to scroll to\", {\n          location\n        }, LogLevel.DEBUG);\n        publish(scrollToIndex, location);\n      } else {\n        log2(\"list did not change, scroll successful\", {}, LogLevel.DEBUG);\n      }\n    };\n    cleanup();\n    if (behavior === \"smooth\") {\n      let listChanged = false;\n      unsubscribeListRefresh = subscribe(listRefresh, changed => {\n        listChanged = listChanged || changed;\n      });\n      unsubscribeNextListRefresh = handleNext(smoothScrollTargetReached, () => {\n        retry(listChanged);\n      });\n    } else {\n      unsubscribeNextListRefresh = handleNext(pipe(listRefresh, watchChangesFor(150)), retry);\n    }\n    cleartTimeoutRef = setTimeout(() => {\n      cleanup();\n    }, 1200);\n    publish(scrollingInProgress, true);\n    log2(\"scrolling from index to\", {\n      index,\n      top,\n      behavior\n    }, LogLevel.DEBUG);\n    return {\n      top,\n      behavior\n    };\n  })), scrollTo);\n  return {\n    scrollToIndex,\n    topListHeight\n  };\n}, tup(sizeSystem, domIOSystem, loggerSystem), {\n  singleton: true\n});\nfunction watchChangesFor(limit) {\n  return done => {\n    const timeoutRef = setTimeout(() => {\n      done(false);\n    }, limit);\n    return value => {\n      if (value) {\n        done(true);\n        clearTimeout(timeoutRef);\n      }\n    };\n  };\n}\nconst UP = \"up\";\nconst DOWN = \"down\";\nconst NONE$1 = \"none\";\nconst INITIAL_BOTTOM_STATE = {\n  atBottom: false,\n  notAtBottomBecause: \"NOT_SHOWING_LAST_ITEM\",\n  state: {\n    offsetBottom: 0,\n    scrollTop: 0,\n    viewportHeight: 0,\n    scrollHeight: 0\n  }\n};\nconst DEFAULT_AT_TOP_THRESHOLD = 0;\nconst stateFlagsSystem = system(_ref22 => {\n  let [{\n    scrollContainerState,\n    scrollTop,\n    viewportHeight,\n    headerHeight,\n    footerHeight,\n    scrollBy\n  }] = _ref22;\n  const isAtBottom = statefulStream(false);\n  const isAtTop = statefulStream(true);\n  const atBottomStateChange = stream();\n  const atTopStateChange = stream();\n  const atBottomThreshold = statefulStream(4);\n  const atTopThreshold = statefulStream(DEFAULT_AT_TOP_THRESHOLD);\n  const isScrolling = statefulStreamFromEmitter(pipe(merge(pipe(duc(scrollTop), skip(1), mapTo(true)), pipe(duc(scrollTop), skip(1), mapTo(false), debounceTime(100))), distinctUntilChanged()), false);\n  const isScrollingBy = statefulStreamFromEmitter(pipe(merge(pipe(scrollBy, mapTo(true)), pipe(scrollBy, mapTo(false), debounceTime(200))), distinctUntilChanged()), false);\n  connect(pipe(combineLatest(duc(scrollTop), duc(atTopThreshold)), map(_ref23 => {\n    let [top, atTopThreshold2] = _ref23;\n    return top <= atTopThreshold2;\n  }), distinctUntilChanged()), isAtTop);\n  connect(pipe(isAtTop, throttleTime(50)), atTopStateChange);\n  const atBottomState = streamFromEmitter(pipe(combineLatest(scrollContainerState, duc(viewportHeight), duc(headerHeight), duc(footerHeight), duc(atBottomThreshold)), scan((current, _ref24) => {\n    let [{\n      scrollTop: scrollTop2,\n      scrollHeight\n    }, viewportHeight2, _headerHeight, _footerHeight, atBottomThreshold2] = _ref24;\n    const isAtBottom2 = scrollTop2 + viewportHeight2 - scrollHeight > -atBottomThreshold2;\n    const state = {\n      viewportHeight: viewportHeight2,\n      scrollTop: scrollTop2,\n      scrollHeight\n    };\n    if (isAtBottom2) {\n      let atBottomBecause;\n      let scrollTopDelta;\n      if (scrollTop2 > current.state.scrollTop) {\n        atBottomBecause = \"SCROLLED_DOWN\";\n        scrollTopDelta = current.state.scrollTop - scrollTop2;\n      } else {\n        atBottomBecause = \"SIZE_DECREASED\";\n        scrollTopDelta = current.state.scrollTop - scrollTop2 || current.scrollTopDelta;\n      }\n      return {\n        atBottom: true,\n        state,\n        atBottomBecause,\n        scrollTopDelta\n      };\n    }\n    let notAtBottomBecause;\n    if (state.scrollHeight > current.state.scrollHeight) {\n      notAtBottomBecause = \"SIZE_INCREASED\";\n    } else if (viewportHeight2 < current.state.viewportHeight) {\n      notAtBottomBecause = \"VIEWPORT_HEIGHT_DECREASING\";\n    } else if (scrollTop2 < current.state.scrollTop) {\n      notAtBottomBecause = \"SCROLLING_UPWARDS\";\n    } else {\n      notAtBottomBecause = \"NOT_FULLY_SCROLLED_TO_LAST_ITEM_BOTTOM\";\n    }\n    return {\n      atBottom: false,\n      notAtBottomBecause,\n      state\n    };\n  }, INITIAL_BOTTOM_STATE), distinctUntilChanged((prev, next) => {\n    return prev && prev.atBottom === next.atBottom;\n  })));\n  const lastJumpDueToItemResize = statefulStreamFromEmitter(pipe(scrollContainerState, scan((current, _ref25) => {\n    let {\n      scrollTop: scrollTop2,\n      scrollHeight,\n      viewportHeight: viewportHeight2\n    } = _ref25;\n    if (!approximatelyEqual(current.scrollHeight, scrollHeight)) {\n      const atBottom = scrollHeight - (scrollTop2 + viewportHeight2) < 1;\n      if (current.scrollTop !== scrollTop2 && atBottom) {\n        return {\n          scrollHeight,\n          scrollTop: scrollTop2,\n          jump: current.scrollTop - scrollTop2,\n          changed: true\n        };\n      } else {\n        return {\n          scrollHeight,\n          scrollTop: scrollTop2,\n          jump: 0,\n          changed: true\n        };\n      }\n    } else {\n      return {\n        scrollTop: scrollTop2,\n        scrollHeight,\n        jump: 0,\n        changed: false\n      };\n    }\n  }, {\n    scrollHeight: 0,\n    jump: 0,\n    scrollTop: 0,\n    changed: false\n  }), filter(value => value.changed), map(value => value.jump)), 0);\n  connect(pipe(atBottomState, map(state => state.atBottom)), isAtBottom);\n  connect(pipe(isAtBottom, throttleTime(50)), atBottomStateChange);\n  const scrollDirection = statefulStream(DOWN);\n  connect(pipe(scrollContainerState, map(_ref26 => {\n    let {\n      scrollTop: scrollTop2\n    } = _ref26;\n    return scrollTop2;\n  }), distinctUntilChanged(), scan((acc, scrollTop2) => {\n    if (getValue(isScrollingBy)) {\n      return {\n        direction: acc.direction,\n        prevScrollTop: scrollTop2\n      };\n    }\n    return {\n      direction: scrollTop2 < acc.prevScrollTop ? UP : DOWN,\n      prevScrollTop: scrollTop2\n    };\n  }, {\n    direction: DOWN,\n    prevScrollTop: 0\n  }), map(value => value.direction)), scrollDirection);\n  connect(pipe(scrollContainerState, throttleTime(50), mapTo(NONE$1)), scrollDirection);\n  const scrollVelocity = statefulStream(0);\n  connect(pipe(isScrolling, filter(value => !value), mapTo(0)), scrollVelocity);\n  connect(pipe(scrollTop, throttleTime(100), withLatestFrom(isScrolling), filter(_ref27 => {\n    let [_, isScrolling2] = _ref27;\n    return !!isScrolling2;\n  }), scan((_ref28, _ref29) => {\n    let [_, prev] = _ref28;\n    let [next] = _ref29;\n    return [prev, next];\n  }, [0, 0]), map(_ref30 => {\n    let [prev, next] = _ref30;\n    return next - prev;\n  })), scrollVelocity);\n  return {\n    isScrolling,\n    isAtTop,\n    isAtBottom,\n    atBottomState,\n    atTopStateChange,\n    atBottomStateChange,\n    scrollDirection,\n    atBottomThreshold,\n    atTopThreshold,\n    scrollVelocity,\n    lastJumpDueToItemResize\n  };\n}, tup(domIOSystem));\nconst propsReadySystem = system(_ref31 => {\n  let [{\n    log\n  }] = _ref31;\n  const propsReady = statefulStream(false);\n  const didMount = streamFromEmitter(pipe(propsReady, filter(ready => ready), distinctUntilChanged()));\n  subscribe(propsReady, value => {\n    value && getValue(log)(\"props updated\", {}, LogLevel.DEBUG);\n  });\n  return {\n    propsReady,\n    didMount\n  };\n}, tup(loggerSystem), {\n  singleton: true\n});\nfunction getInitialTopMostItemIndexNumber(location, totalCount) {\n  const lastIndex = totalCount - 1;\n  const index = typeof location === \"number\" ? location : location.index === \"LAST\" ? lastIndex : location.index;\n  return index;\n}\nconst initialTopMostItemIndexSystem = system(_ref32 => {\n  let [{\n    sizes,\n    listRefresh,\n    defaultItemSize\n  }, {\n    scrollTop\n  }, {\n    scrollToIndex\n  }, {\n    didMount\n  }] = _ref32;\n  const scrolledToInitialItem = statefulStream(true);\n  const initialTopMostItemIndex = statefulStream(0);\n  connect(pipe(didMount, withLatestFrom(initialTopMostItemIndex), filter(_ref33 => {\n    let [_, location] = _ref33;\n    return !!location;\n  }), mapTo(false)), scrolledToInitialItem);\n  subscribe(pipe(combineLatest(listRefresh, didMount), withLatestFrom(scrolledToInitialItem, sizes, defaultItemSize), filter(_ref34 => {\n    let [[, didMount2], scrolledToInitialItem2, {\n      sizeTree\n    }, defaultItemSize2] = _ref34;\n    return didMount2 && (!empty(sizeTree) || defaultItemSize2 !== void 0) && !scrolledToInitialItem2;\n  }), withLatestFrom(initialTopMostItemIndex)), _ref35 => {\n    let [, initialTopMostItemIndex2] = _ref35;\n    setTimeout(() => {\n      handleNext(scrollTop, () => {\n        publish(scrolledToInitialItem, true);\n      });\n      publish(scrollToIndex, initialTopMostItemIndex2);\n    });\n  });\n  return {\n    scrolledToInitialItem,\n    initialTopMostItemIndex\n  };\n}, tup(sizeSystem, domIOSystem, scrollToIndexSystem, propsReadySystem), {\n  singleton: true\n});\nfunction normalizeFollowOutput(follow) {\n  if (!follow) {\n    return false;\n  }\n  return follow === \"smooth\" ? \"smooth\" : \"auto\";\n}\nconst behaviorFromFollowOutput = (follow, isAtBottom) => {\n  if (typeof follow === \"function\") {\n    return normalizeFollowOutput(follow(isAtBottom));\n  }\n  return isAtBottom && normalizeFollowOutput(follow);\n};\nconst followOutputSystem = system(_ref36 => {\n  let [{\n    totalCount,\n    listRefresh\n  }, {\n    isAtBottom,\n    atBottomState\n  }, {\n    scrollToIndex\n  }, {\n    scrolledToInitialItem\n  }, {\n    propsReady,\n    didMount\n  }, {\n    log\n  }, {\n    scrollingInProgress\n  }] = _ref36;\n  const followOutput = statefulStream(false);\n  const autoscrollToBottom = stream();\n  let pendingScrollHandle = null;\n  function scrollToBottom(followOutputBehavior) {\n    publish(scrollToIndex, {\n      index: \"LAST\",\n      align: \"end\",\n      behavior: followOutputBehavior\n    });\n  }\n  subscribe(pipe(combineLatest(pipe(duc(totalCount), skip(1)), didMount), withLatestFrom(duc(followOutput), isAtBottom, scrolledToInitialItem, scrollingInProgress), map(_ref37 => {\n    let [[totalCount2, didMount2], followOutput2, isAtBottom2, scrolledToInitialItem2, scrollingInProgress2] = _ref37;\n    let shouldFollow = didMount2 && scrolledToInitialItem2;\n    let followOutputBehavior = \"auto\";\n    if (shouldFollow) {\n      followOutputBehavior = behaviorFromFollowOutput(followOutput2, isAtBottom2 || scrollingInProgress2);\n      shouldFollow = shouldFollow && !!followOutputBehavior;\n    }\n    return {\n      totalCount: totalCount2,\n      shouldFollow,\n      followOutputBehavior\n    };\n  }), filter(_ref38 => {\n    let {\n      shouldFollow\n    } = _ref38;\n    return shouldFollow;\n  })), _ref39 => {\n    let {\n      totalCount: totalCount2,\n      followOutputBehavior\n    } = _ref39;\n    if (pendingScrollHandle) {\n      pendingScrollHandle();\n      pendingScrollHandle = null;\n    }\n    pendingScrollHandle = handleNext(listRefresh, () => {\n      getValue(log)(\"following output to \", {\n        totalCount: totalCount2\n      }, LogLevel.DEBUG);\n      scrollToBottom(followOutputBehavior);\n      pendingScrollHandle = null;\n    });\n  });\n  function trapNextSizeIncrease(followOutput2) {\n    const cancel = handleNext(atBottomState, state => {\n      if (followOutput2 && !state.atBottom && state.notAtBottomBecause === \"SIZE_INCREASED\" && !pendingScrollHandle) {\n        getValue(log)(\"scrolling to bottom due to increased size\", {}, LogLevel.DEBUG);\n        scrollToBottom(\"auto\");\n      }\n    });\n    setTimeout(cancel, 100);\n  }\n  subscribe(pipe(combineLatest(duc(followOutput), totalCount, propsReady), filter(_ref40 => {\n    let [follow,, ready] = _ref40;\n    return follow && ready;\n  }), scan((_ref41, _ref42) => {\n    let {\n      value\n    } = _ref41;\n    let [, next] = _ref42;\n    return {\n      refreshed: value === next,\n      value: next\n    };\n  }, {\n    refreshed: false,\n    value: 0\n  }), filter(_ref43 => {\n    let {\n      refreshed\n    } = _ref43;\n    return refreshed;\n  }), withLatestFrom(followOutput, totalCount)), _ref44 => {\n    let [, followOutput2] = _ref44;\n    trapNextSizeIncrease(followOutput2 !== false);\n  });\n  subscribe(autoscrollToBottom, () => {\n    trapNextSizeIncrease(getValue(followOutput) !== false);\n  });\n  subscribe(combineLatest(duc(followOutput), atBottomState), _ref45 => {\n    let [followOutput2, state] = _ref45;\n    if (followOutput2 && !state.atBottom && state.notAtBottomBecause === \"VIEWPORT_HEIGHT_DECREASING\") {\n      scrollToBottom(\"auto\");\n    }\n  });\n  return {\n    followOutput,\n    autoscrollToBottom\n  };\n}, tup(sizeSystem, stateFlagsSystem, scrollToIndexSystem, initialTopMostItemIndexSystem, propsReadySystem, loggerSystem, domIOSystem));\nfunction groupCountsToIndicesAndCount(counts) {\n  return counts.reduce((acc, groupCount) => {\n    acc.groupIndices.push(acc.totalCount);\n    acc.totalCount += groupCount + 1;\n    return acc;\n  }, {\n    totalCount: 0,\n    groupIndices: []\n  });\n}\nconst groupedListSystem = system(_ref46 => {\n  let [{\n    totalCount,\n    groupIndices,\n    sizes\n  }, {\n    scrollTop,\n    headerHeight\n  }] = _ref46;\n  const groupCounts = stream();\n  const topItemsIndexes = stream();\n  const groupIndicesAndCount = streamFromEmitter(pipe(groupCounts, map(groupCountsToIndicesAndCount)));\n  connect(pipe(groupIndicesAndCount, map(value => value.totalCount)), totalCount);\n  connect(pipe(groupIndicesAndCount, map(value => value.groupIndices)), groupIndices);\n  connect(pipe(combineLatest(scrollTop, sizes, headerHeight), filter(_ref47 => {\n    let [_, sizes2] = _ref47;\n    return hasGroups(sizes2);\n  }), map(_ref48 => {\n    let [scrollTop2, state, headerHeight2] = _ref48;\n    return findMaxKeyValue(state.groupOffsetTree, Math.max(scrollTop2 - headerHeight2, 0), \"v\")[0];\n  }), distinctUntilChanged(), map(index => [index])), topItemsIndexes);\n  return {\n    groupCounts,\n    topItemsIndexes\n  };\n}, tup(sizeSystem, domIOSystem));\nfunction tupleComparator(prev, current) {\n  return !!(prev && prev[0] === current[0] && prev[1] === current[1]);\n}\nfunction rangeComparator(prev, next) {\n  return !!(prev && prev.startIndex === next.startIndex && prev.endIndex === next.endIndex);\n}\nconst TOP = \"top\";\nconst BOTTOM = \"bottom\";\nconst NONE = \"none\";\nfunction getOverscan(overscan, end, direction) {\n  if (typeof overscan === \"number\") {\n    return direction === UP && end === TOP || direction === DOWN && end === BOTTOM ? overscan : 0;\n  } else {\n    if (direction === UP) {\n      return end === TOP ? overscan.main : overscan.reverse;\n    } else {\n      return end === BOTTOM ? overscan.main : overscan.reverse;\n    }\n  }\n}\nfunction getViewportIncrease(value, end) {\n  return typeof value === \"number\" ? value : value[end] || 0;\n}\nconst sizeRangeSystem = system(_ref49 => {\n  let [{\n    scrollTop,\n    viewportHeight,\n    deviation,\n    headerHeight,\n    fixedHeaderHeight\n  }] = _ref49;\n  const listBoundary = stream();\n  const topListHeight = statefulStream(0);\n  const increaseViewportBy = statefulStream(0);\n  const overscan = statefulStream(0);\n  const visibleRange = statefulStreamFromEmitter(pipe(combineLatest(duc(scrollTop), duc(viewportHeight), duc(headerHeight), duc(listBoundary, tupleComparator), duc(overscan), duc(topListHeight), duc(fixedHeaderHeight), duc(deviation), duc(increaseViewportBy)), map(_ref50 => {\n    let [scrollTop2, viewportHeight2, headerHeight2, [listTop, listBottom], overscan2, topListHeight2, fixedHeaderHeight2, deviation2, increaseViewportBy2] = _ref50;\n    const top = scrollTop2 - deviation2;\n    const stickyHeaderHeight = topListHeight2 + fixedHeaderHeight2;\n    const headerVisible = Math.max(headerHeight2 - top, 0);\n    let direction = NONE;\n    const topViewportAddition = getViewportIncrease(increaseViewportBy2, TOP);\n    const bottomViewportAddition = getViewportIncrease(increaseViewportBy2, BOTTOM);\n    listTop -= deviation2;\n    listTop += headerHeight2 + fixedHeaderHeight2;\n    listBottom += headerHeight2 + fixedHeaderHeight2;\n    listBottom -= deviation2;\n    if (listTop > scrollTop2 + stickyHeaderHeight - topViewportAddition) {\n      direction = UP;\n    }\n    if (listBottom < scrollTop2 - headerVisible + viewportHeight2 + bottomViewportAddition) {\n      direction = DOWN;\n    }\n    if (direction !== NONE) {\n      return [Math.max(top - headerHeight2 - getOverscan(overscan2, TOP, direction) - topViewportAddition, 0), top - headerVisible - fixedHeaderHeight2 + viewportHeight2 + getOverscan(overscan2, BOTTOM, direction) + bottomViewportAddition];\n    }\n    return null;\n  }), filter(value => value != null), distinctUntilChanged(tupleComparator)), [0, 0]);\n  return {\n    listBoundary,\n    overscan,\n    topListHeight,\n    increaseViewportBy,\n    visibleRange\n  };\n}, tup(domIOSystem), {\n  singleton: true\n});\nfunction probeItemSet(index, sizes, data) {\n  if (hasGroups(sizes)) {\n    const itemIndex = originalIndexFromItemIndex(index, sizes);\n    const groupIndex = findMaxKeyValue(sizes.groupOffsetTree, itemIndex)[0];\n    return [{\n      index: groupIndex,\n      size: 0,\n      offset: 0\n    }, {\n      index: itemIndex,\n      size: 0,\n      offset: 0,\n      data: data && data[0]\n    }];\n  }\n  return [{\n    index,\n    size: 0,\n    offset: 0,\n    data: data && data[0]\n  }];\n}\nconst EMPTY_LIST_STATE = {\n  items: [],\n  topItems: [],\n  offsetTop: 0,\n  offsetBottom: 0,\n  top: 0,\n  bottom: 0,\n  topListHeight: 0,\n  totalCount: 0,\n  firstItemIndex: 0\n};\nfunction transposeItems(items, sizes, firstItemIndex) {\n  if (items.length === 0) {\n    return [];\n  }\n  if (!hasGroups(sizes)) {\n    return items.map(item => ({\n      ...item,\n      index: item.index + firstItemIndex,\n      originalIndex: item.index\n    }));\n  }\n  const startIndex = items[0].index;\n  const endIndex = items[items.length - 1].index;\n  const transposedItems = [];\n  const groupRanges = rangesWithin(sizes.groupOffsetTree, startIndex, endIndex);\n  let currentRange = void 0;\n  let currentGroupIndex = 0;\n  for (const item of items) {\n    if (!currentRange || currentRange.end < item.index) {\n      currentRange = groupRanges.shift();\n      currentGroupIndex = sizes.groupIndices.indexOf(currentRange.start);\n    }\n    let transposedItem;\n    if (item.index === currentRange.start) {\n      transposedItem = {\n        type: \"group\",\n        index: currentGroupIndex\n      };\n    } else {\n      transposedItem = {\n        index: item.index - (currentGroupIndex + 1) + firstItemIndex,\n        groupIndex: currentGroupIndex\n      };\n    }\n    transposedItems.push({\n      ...transposedItem,\n      size: item.size,\n      offset: item.offset,\n      originalIndex: item.index,\n      data: item.data\n    });\n  }\n  return transposedItems;\n}\nfunction buildListState(items, topItems, totalCount, gap, sizes, firstItemIndex) {\n  const {\n    lastSize,\n    lastOffset,\n    lastIndex\n  } = sizes;\n  let offsetTop = 0;\n  let bottom = 0;\n  if (items.length > 0) {\n    offsetTop = items[0].offset;\n    const lastItem = items[items.length - 1];\n    bottom = lastItem.offset + lastItem.size;\n  }\n  const itemCount = totalCount - lastIndex;\n  const total = lastOffset + itemCount * lastSize + (itemCount - 1) * gap;\n  const top = offsetTop;\n  const offsetBottom = total - bottom;\n  return {\n    items: transposeItems(items, sizes, firstItemIndex),\n    topItems: transposeItems(topItems, sizes, firstItemIndex),\n    topListHeight: topItems.reduce((height, item) => item.size + height, 0),\n    offsetTop,\n    offsetBottom,\n    top,\n    bottom,\n    totalCount,\n    firstItemIndex\n  };\n}\nconst listStateSystem = system(_ref51 => {\n  let [{\n    sizes,\n    totalCount,\n    data,\n    firstItemIndex,\n    gap\n  }, groupedListSystem2, {\n    visibleRange,\n    listBoundary,\n    topListHeight: rangeTopListHeight\n  }, {\n    scrolledToInitialItem,\n    initialTopMostItemIndex\n  }, {\n    topListHeight\n  }, stateFlags, {\n    didMount\n  }, {\n    recalcInProgress\n  }] = _ref51;\n  const topItemsIndexes = statefulStream([]);\n  const itemsRendered = stream();\n  connect(groupedListSystem2.topItemsIndexes, topItemsIndexes);\n  const listState = statefulStreamFromEmitter(pipe(combineLatest(didMount, recalcInProgress, duc(visibleRange, tupleComparator), duc(totalCount), duc(sizes), duc(initialTopMostItemIndex), scrolledToInitialItem, duc(topItemsIndexes), duc(firstItemIndex), duc(gap), data), filter(_ref52 => {\n    let [mount, recalcInProgress2,, totalCount2,,,,,,, data2] = _ref52;\n    const dataChangeInProgress = data2 && data2.length !== totalCount2;\n    return mount && !recalcInProgress2 && !dataChangeInProgress;\n  }), map(_ref53 => {\n    let [,, [startOffset, endOffset], totalCount2, sizes2, initialTopMostItemIndex2, scrolledToInitialItem2, topItemsIndexes2, firstItemIndex2, gap2, data2] = _ref53;\n    const sizesValue = sizes2;\n    const {\n      sizeTree,\n      offsetTree\n    } = sizesValue;\n    if (totalCount2 === 0 || startOffset === 0 && endOffset === 0) {\n      return {\n        ...EMPTY_LIST_STATE,\n        totalCount: totalCount2\n      };\n    }\n    if (empty(sizeTree)) {\n      return buildListState(probeItemSet(getInitialTopMostItemIndexNumber(initialTopMostItemIndex2, totalCount2), sizesValue, data2), [], totalCount2, gap2, sizesValue, firstItemIndex2);\n    }\n    const topItems = [];\n    if (topItemsIndexes2.length > 0) {\n      const startIndex = topItemsIndexes2[0];\n      const endIndex = topItemsIndexes2[topItemsIndexes2.length - 1];\n      let offset = 0;\n      for (const range of rangesWithin(sizeTree, startIndex, endIndex)) {\n        const size = range.value;\n        const rangeStartIndex = Math.max(range.start, startIndex);\n        const rangeEndIndex = Math.min(range.end, endIndex);\n        for (let i = rangeStartIndex; i <= rangeEndIndex; i++) {\n          topItems.push({\n            index: i,\n            size,\n            offset,\n            data: data2 && data2[i]\n          });\n          offset += size;\n        }\n      }\n    }\n    if (!scrolledToInitialItem2) {\n      return buildListState([], topItems, totalCount2, gap2, sizesValue, firstItemIndex2);\n    }\n    const minStartIndex = topItemsIndexes2.length > 0 ? topItemsIndexes2[topItemsIndexes2.length - 1] + 1 : 0;\n    const offsetPointRanges = rangesWithinOffsets(offsetTree, startOffset, endOffset, minStartIndex);\n    if (offsetPointRanges.length === 0) {\n      return null;\n    }\n    const maxIndex = totalCount2 - 1;\n    const items = tap([], result => {\n      for (const range of offsetPointRanges) {\n        const point = range.value;\n        let offset = point.offset;\n        let rangeStartIndex = range.start;\n        const size = point.size;\n        if (point.offset < startOffset) {\n          rangeStartIndex += Math.floor((startOffset - point.offset + gap2) / (size + gap2));\n          const itemCount = rangeStartIndex - range.start;\n          offset += itemCount * size + itemCount * gap2;\n        }\n        if (rangeStartIndex < minStartIndex) {\n          offset += (minStartIndex - rangeStartIndex) * size;\n          rangeStartIndex = minStartIndex;\n        }\n        const endIndex = Math.min(range.end, maxIndex);\n        for (let i = rangeStartIndex; i <= endIndex; i++) {\n          if (offset >= endOffset) {\n            break;\n          }\n          result.push({\n            index: i,\n            size,\n            offset,\n            data: data2 && data2[i]\n          });\n          offset += size + gap2;\n        }\n      }\n    });\n    return buildListState(items, topItems, totalCount2, gap2, sizesValue, firstItemIndex2);\n  }), filter(value => value !== null), distinctUntilChanged()), EMPTY_LIST_STATE);\n  connect(pipe(data, filter(data2 => data2 !== void 0), map(data2 => data2 == null ? void 0 : data2.length)), totalCount);\n  connect(pipe(listState, map(value => value.topListHeight)), topListHeight);\n  connect(topListHeight, rangeTopListHeight);\n  connect(pipe(listState, map(state => [state.top, state.bottom])), listBoundary);\n  connect(pipe(listState, map(state => state.items)), itemsRendered);\n  const endReached = streamFromEmitter(pipe(listState, filter(_ref54 => {\n    let {\n      items\n    } = _ref54;\n    return items.length > 0;\n  }), withLatestFrom(totalCount, data), filter(_ref55 => {\n    let [{\n      items\n    }, totalCount2] = _ref55;\n    return items[items.length - 1].originalIndex === totalCount2 - 1;\n  }), map(_ref56 => {\n    let [, totalCount2, data2] = _ref56;\n    return [totalCount2 - 1, data2];\n  }), distinctUntilChanged(tupleComparator), map(_ref57 => {\n    let [count] = _ref57;\n    return count;\n  })));\n  const startReached = streamFromEmitter(pipe(listState, throttleTime(200), filter(_ref58 => {\n    let {\n      items,\n      topItems\n    } = _ref58;\n    return items.length > 0 && items[0].originalIndex === topItems.length;\n  }), map(_ref59 => {\n    let {\n      items\n    } = _ref59;\n    return items[0].index;\n  }), distinctUntilChanged()));\n  const rangeChanged = streamFromEmitter(pipe(listState, filter(_ref60 => {\n    let {\n      items\n    } = _ref60;\n    return items.length > 0;\n  }), map(_ref61 => {\n    let {\n      items\n    } = _ref61;\n    let startIndex = 0;\n    let endIndex = items.length - 1;\n    while (items[startIndex].type === \"group\" && startIndex < endIndex) {\n      startIndex++;\n    }\n    while (items[endIndex].type === \"group\" && endIndex > startIndex) {\n      endIndex--;\n    }\n    return {\n      startIndex: items[startIndex].index,\n      endIndex: items[endIndex].index\n    };\n  }), distinctUntilChanged(rangeComparator)));\n  return {\n    listState,\n    topItemsIndexes,\n    endReached,\n    startReached,\n    rangeChanged,\n    itemsRendered,\n    ...stateFlags\n  };\n}, tup(sizeSystem, groupedListSystem, sizeRangeSystem, initialTopMostItemIndexSystem, scrollToIndexSystem, stateFlagsSystem, propsReadySystem, recalcSystem), {\n  singleton: true\n});\nconst initialItemCountSystem = system(_ref62 => {\n  let [{\n    sizes,\n    firstItemIndex,\n    data,\n    gap\n  }, {\n    listState\n  }, {\n    didMount\n  }] = _ref62;\n  const initialItemCount = statefulStream(0);\n  connect(pipe(didMount, withLatestFrom(initialItemCount), filter(_ref63 => {\n    let [, count] = _ref63;\n    return count !== 0;\n  }), withLatestFrom(sizes, firstItemIndex, gap, data), map(_ref64 => {\n    let [[, count], sizes2, firstItemIndex2, gap2, data2 = []] = _ref64;\n    let includedGroupsCount = 0;\n    if (sizes2.groupIndices.length > 0) {\n      for (const index of sizes2.groupIndices) {\n        if (index - includedGroupsCount >= count) {\n          break;\n        }\n        includedGroupsCount++;\n      }\n    }\n    const adjustedCount = count + includedGroupsCount;\n    const items = Array.from({\n      length: adjustedCount\n    }).map((_, index) => ({\n      index,\n      size: 0,\n      offset: 0,\n      data: data2[index]\n    }));\n    return buildListState(items, [], adjustedCount, gap2, sizes2, firstItemIndex2);\n  })), listState);\n  return {\n    initialItemCount\n  };\n}, tup(sizeSystem, listStateSystem, propsReadySystem), {\n  singleton: true\n});\nconst scrollSeekSystem = system(_ref65 => {\n  let [{\n    scrollVelocity\n  }] = _ref65;\n  const isSeeking = statefulStream(false);\n  const rangeChanged = stream();\n  const scrollSeekConfiguration = statefulStream(false);\n  connect(pipe(scrollVelocity, withLatestFrom(scrollSeekConfiguration, isSeeking, rangeChanged), filter(_ref66 => {\n    let [_, config] = _ref66;\n    return !!config;\n  }), map(_ref67 => {\n    let [speed, config, isSeeking2, range] = _ref67;\n    const {\n      exit,\n      enter\n    } = config;\n    if (isSeeking2) {\n      if (exit(speed, range)) {\n        return false;\n      }\n    } else {\n      if (enter(speed, range)) {\n        return true;\n      }\n    }\n    return isSeeking2;\n  }), distinctUntilChanged()), isSeeking);\n  subscribe(pipe(combineLatest(isSeeking, scrollVelocity, rangeChanged), withLatestFrom(scrollSeekConfiguration)), _ref68 => {\n    let [[isSeeking2, velocity, range], config] = _ref68;\n    return isSeeking2 && config && config.change && config.change(velocity, range);\n  });\n  return {\n    isSeeking,\n    scrollSeekConfiguration,\n    scrollVelocity,\n    scrollSeekRangeChanged: rangeChanged\n  };\n}, tup(stateFlagsSystem), {\n  singleton: true\n});\nconst topItemCountSystem = system(_ref69 => {\n  let [{\n    topItemsIndexes\n  }] = _ref69;\n  const topItemCount = statefulStream(0);\n  connect(pipe(topItemCount, filter(length => length > 0), map(length => Array.from({\n    length\n  }).map((_, index) => index))), topItemsIndexes);\n  return {\n    topItemCount\n  };\n}, tup(listStateSystem));\nconst totalListHeightSystem = system(_ref70 => {\n  let [{\n    footerHeight,\n    headerHeight,\n    fixedHeaderHeight,\n    fixedFooterHeight\n  }, {\n    listState\n  }] = _ref70;\n  const totalListHeightChanged = stream();\n  const totalListHeight = statefulStreamFromEmitter(pipe(combineLatest(footerHeight, fixedFooterHeight, headerHeight, fixedHeaderHeight, listState), map(_ref71 => {\n    let [footerHeight2, fixedFooterHeight2, headerHeight2, fixedHeaderHeight2, listState2] = _ref71;\n    return footerHeight2 + fixedFooterHeight2 + headerHeight2 + fixedHeaderHeight2 + listState2.offsetBottom + listState2.bottom;\n  })), 0);\n  connect(duc(totalListHeight), totalListHeightChanged);\n  return {\n    totalListHeight,\n    totalListHeightChanged\n  };\n}, tup(domIOSystem, listStateSystem), {\n  singleton: true\n});\nfunction simpleMemoize(func) {\n  let called = false;\n  let result;\n  return () => {\n    if (!called) {\n      called = true;\n      result = func();\n    }\n    return result;\n  };\n}\nconst isMobileSafari = simpleMemoize(() => {\n  return /iP(ad|od|hone)/i.test(navigator.userAgent) && /WebKit/i.test(navigator.userAgent);\n});\nconst upwardScrollFixSystem = system(_ref72 => {\n  let [{\n    scrollBy,\n    scrollTop,\n    deviation,\n    scrollingInProgress\n  }, {\n    isScrolling,\n    isAtBottom,\n    scrollDirection,\n    lastJumpDueToItemResize\n  }, {\n    listState\n  }, {\n    beforeUnshiftWith,\n    shiftWithOffset,\n    sizes,\n    gap\n  }, {\n    log\n  }, {\n    recalcInProgress\n  }] = _ref72;\n  const deviationOffset = streamFromEmitter(pipe(listState, withLatestFrom(lastJumpDueToItemResize), scan((_ref73, _ref74) => {\n    let [, prevItems, prevTotalCount, prevTotalHeight] = _ref73;\n    let [{\n      items,\n      totalCount,\n      bottom,\n      offsetBottom\n    }, lastJumpDueToItemResize2] = _ref74;\n    const totalHeight = bottom + offsetBottom;\n    let newDev = 0;\n    if (prevTotalCount === totalCount) {\n      if (prevItems.length > 0 && items.length > 0) {\n        const atStart = items[0].originalIndex === 0 && prevItems[0].originalIndex === 0;\n        if (!atStart) {\n          newDev = totalHeight - prevTotalHeight;\n          if (newDev !== 0) {\n            newDev += lastJumpDueToItemResize2;\n          }\n        }\n      }\n    }\n    return [newDev, items, totalCount, totalHeight];\n  }, [0, [], 0, 0]), filter(_ref75 => {\n    let [amount] = _ref75;\n    return amount !== 0;\n  }), withLatestFrom(scrollTop, scrollDirection, scrollingInProgress, isAtBottom, log), filter(_ref76 => {\n    let [, scrollTop2, scrollDirection2, scrollingInProgress2] = _ref76;\n    return !scrollingInProgress2 && scrollTop2 !== 0 && scrollDirection2 === UP;\n  }), map(_ref77 => {\n    let [[amount],,,,, log2] = _ref77;\n    log2(\"Upward scrolling compensation\", {\n      amount\n    }, LogLevel.DEBUG);\n    return amount;\n  })));\n  function scrollByWith(offset) {\n    if (offset > 0) {\n      publish(scrollBy, {\n        top: -offset,\n        behavior: \"auto\"\n      });\n      publish(deviation, 0);\n    } else {\n      publish(deviation, 0);\n      publish(scrollBy, {\n        top: -offset,\n        behavior: \"auto\"\n      });\n    }\n  }\n  subscribe(pipe(deviationOffset, withLatestFrom(deviation, isScrolling)), _ref78 => {\n    let [offset, deviationAmount, isScrolling2] = _ref78;\n    if (isScrolling2 && isMobileSafari()) {\n      publish(deviation, deviationAmount - offset);\n    } else {\n      scrollByWith(-offset);\n    }\n  });\n  subscribe(pipe(combineLatest(statefulStreamFromEmitter(isScrolling, false), deviation, recalcInProgress), filter(_ref79 => {\n    let [is, deviation2, recalc] = _ref79;\n    return !is && !recalc && deviation2 !== 0;\n  }), map(_ref80 => {\n    let [_, deviation2] = _ref80;\n    return deviation2;\n  }), throttleTime(1)), scrollByWith);\n  connect(pipe(shiftWithOffset, map(offset => {\n    return {\n      top: -offset\n    };\n  })), scrollBy);\n  subscribe(pipe(beforeUnshiftWith, withLatestFrom(sizes, gap), map(_ref81 => {\n    let [offset, {\n      lastSize\n    }, gap2] = _ref81;\n    return offset * lastSize + offset * gap2;\n  })), offset => {\n    publish(deviation, offset);\n    requestAnimationFrame(() => {\n      publish(scrollBy, {\n        top: offset\n      });\n      requestAnimationFrame(() => {\n        publish(deviation, 0);\n        publish(recalcInProgress, false);\n      });\n    });\n  });\n  return {\n    deviation\n  };\n}, tup(domIOSystem, stateFlagsSystem, listStateSystem, sizeSystem, loggerSystem, recalcSystem));\nconst initialScrollTopSystem = system(_ref82 => {\n  let [{\n    totalListHeight\n  }, {\n    didMount\n  }, {\n    scrollTo\n  }] = _ref82;\n  const initialScrollTop = statefulStream(0);\n  subscribe(pipe(didMount, withLatestFrom(initialScrollTop), filter(_ref83 => {\n    let [, offset] = _ref83;\n    return offset !== 0;\n  }), map(_ref84 => {\n    let [, offset] = _ref84;\n    return {\n      top: offset\n    };\n  })), location => {\n    handleNext(pipe(totalListHeight, filter(val => val !== 0)), () => {\n      setTimeout(() => {\n        publish(scrollTo, location);\n      });\n    });\n  });\n  return {\n    initialScrollTop\n  };\n}, tup(totalListHeightSystem, propsReadySystem, domIOSystem), {\n  singleton: true\n});\nconst alignToBottomSystem = system(_ref85 => {\n  let [{\n    viewportHeight\n  }, {\n    totalListHeight\n  }] = _ref85;\n  const alignToBottom = statefulStream(false);\n  const paddingTopAddition = statefulStreamFromEmitter(pipe(combineLatest(alignToBottom, viewportHeight, totalListHeight), filter(_ref86 => {\n    let [enabled] = _ref86;\n    return enabled;\n  }), map(_ref87 => {\n    let [, viewportHeight2, totalListHeight2] = _ref87;\n    return Math.max(0, viewportHeight2 - totalListHeight2);\n  }), distinctUntilChanged()), 0);\n  return {\n    alignToBottom,\n    paddingTopAddition\n  };\n}, tup(domIOSystem, totalListHeightSystem), {\n  singleton: true\n});\nconst windowScrollerSystem = system(_ref88 => {\n  let [{\n    scrollTo,\n    scrollContainerState\n  }] = _ref88;\n  const windowScrollContainerState = stream();\n  const windowViewportRect = stream();\n  const windowScrollTo = stream();\n  const useWindowScroll = statefulStream(false);\n  const customScrollParent = statefulStream(void 0);\n  connect(pipe(combineLatest(windowScrollContainerState, windowViewportRect), map(_ref89 => {\n    let [{\n      viewportHeight,\n      scrollTop: windowScrollTop,\n      scrollHeight\n    }, {\n      offsetTop\n    }] = _ref89;\n    return {\n      scrollTop: Math.max(0, windowScrollTop - offsetTop),\n      scrollHeight,\n      viewportHeight\n    };\n  })), scrollContainerState);\n  connect(pipe(scrollTo, withLatestFrom(windowViewportRect), map(_ref90 => {\n    let [scrollTo2, {\n      offsetTop\n    }] = _ref90;\n    return {\n      ...scrollTo2,\n      top: scrollTo2.top + offsetTop\n    };\n  })), windowScrollTo);\n  return {\n    useWindowScroll,\n    customScrollParent,\n    windowScrollContainerState,\n    windowViewportRect,\n    windowScrollTo\n  };\n}, tup(domIOSystem));\nconst scrollIntoViewSystem = system(_ref91 => {\n  let [{\n    sizes,\n    totalCount,\n    gap\n  }, {\n    scrollTop,\n    viewportHeight,\n    headerHeight,\n    fixedHeaderHeight,\n    fixedFooterHeight,\n    scrollingInProgress\n  }, {\n    scrollToIndex\n  }] = _ref91;\n  const scrollIntoView = stream();\n  connect(pipe(scrollIntoView, withLatestFrom(sizes, viewportHeight, totalCount, headerHeight, fixedHeaderHeight, fixedFooterHeight, scrollTop), withLatestFrom(gap), map(_ref92 => {\n    let [[viewLocation, sizes2, viewportHeight2, totalCount2, headerHeight2, fixedHeaderHeight2, fixedFooterHeight2, scrollTop2], gap2] = _ref92;\n    const {\n      done,\n      behavior,\n      align,\n      ...rest\n    } = viewLocation;\n    let location = null;\n    const actualIndex = originalIndexFromLocation(viewLocation, sizes2, totalCount2 - 1);\n    const itemTop2 = offsetOf(actualIndex, sizes2.offsetTree, gap2) + headerHeight2 + fixedHeaderHeight2;\n    if (itemTop2 < scrollTop2 + fixedHeaderHeight2) {\n      location = {\n        ...rest,\n        behavior,\n        align: align ?? \"start\"\n      };\n    } else {\n      const itemBottom = itemTop2 + findMaxKeyValue(sizes2.sizeTree, actualIndex)[1];\n      if (itemBottom > scrollTop2 + viewportHeight2 - fixedFooterHeight2) {\n        location = {\n          ...rest,\n          behavior,\n          align: align ?? \"end\"\n        };\n      }\n    }\n    if (location) {\n      done && handleNext(pipe(scrollingInProgress, skip(1), filter(value => value === false)), done);\n    } else {\n      done && done();\n    }\n    return location;\n  }), filter(value => value !== null)), scrollToIndex);\n  return {\n    scrollIntoView\n  };\n}, tup(sizeSystem, domIOSystem, scrollToIndexSystem, listStateSystem, loggerSystem), {\n  singleton: true\n});\nconst featureGroup1System = system(_ref93 => {\n  let [sizeRange, initialItemCount, propsReady, scrollSeek, totalListHeight, initialScrollTopSystem2, alignToBottom, windowScroller, scrollIntoView] = _ref93;\n  return {\n    ...sizeRange,\n    ...initialItemCount,\n    ...propsReady,\n    ...scrollSeek,\n    ...totalListHeight,\n    ...initialScrollTopSystem2,\n    ...alignToBottom,\n    ...windowScroller,\n    ...scrollIntoView\n  };\n}, tup(sizeRangeSystem, initialItemCountSystem, propsReadySystem, scrollSeekSystem, totalListHeightSystem, initialScrollTopSystem, alignToBottomSystem, windowScrollerSystem, scrollIntoViewSystem));\nconst listSystem = system(_ref94 => {\n  let [{\n    totalCount,\n    sizeRanges,\n    fixedItemSize,\n    defaultItemSize,\n    trackItemSizes,\n    itemSize,\n    data,\n    firstItemIndex,\n    groupIndices,\n    statefulTotalCount,\n    gap\n  }, {\n    initialTopMostItemIndex,\n    scrolledToInitialItem\n  }, domIO, followOutput, {\n    listState,\n    topItemsIndexes,\n    ...flags\n  }, {\n    scrollToIndex\n  }, _, {\n    topItemCount\n  }, {\n    groupCounts\n  }, featureGroup1, log] = _ref94;\n  connect(flags.rangeChanged, featureGroup1.scrollSeekRangeChanged);\n  connect(pipe(featureGroup1.windowViewportRect, map(value => value.visibleHeight)), domIO.viewportHeight);\n  return {\n    totalCount,\n    data,\n    firstItemIndex,\n    sizeRanges,\n    initialTopMostItemIndex,\n    scrolledToInitialItem,\n    topItemsIndexes,\n    topItemCount,\n    groupCounts,\n    fixedItemHeight: fixedItemSize,\n    defaultItemHeight: defaultItemSize,\n    gap,\n    ...followOutput,\n    statefulTotalCount,\n    listState,\n    scrollToIndex,\n    trackItemSizes,\n    itemSize,\n    groupIndices,\n    ...flags,\n    ...featureGroup1,\n    ...domIO,\n    ...log\n  };\n}, tup(sizeSystem, initialTopMostItemIndexSystem, domIOSystem, followOutputSystem, listStateSystem, scrollToIndexSystem, upwardScrollFixSystem, topItemCountSystem, groupedListSystem, featureGroup1System, loggerSystem));\nconst WEBKIT_STICKY = \"-webkit-sticky\";\nconst STICKY = \"sticky\";\nconst positionStickyCssValue = simpleMemoize(() => {\n  if (typeof document === \"undefined\") {\n    return STICKY;\n  }\n  const node = document.createElement(\"div\");\n  node.style.position = WEBKIT_STICKY;\n  return node.style.position === WEBKIT_STICKY ? WEBKIT_STICKY : STICKY;\n});\nfunction useWindowViewportRectRef(callback, customScrollParent) {\n  const viewportInfo = React.useRef(null);\n  const calculateInfo = React.useCallback(element => {\n    if (element === null || !element.offsetParent) {\n      return;\n    }\n    const rect = element.getBoundingClientRect();\n    const visibleWidth = rect.width;\n    let visibleHeight, offsetTop;\n    if (customScrollParent) {\n      const customScrollParentRect = customScrollParent.getBoundingClientRect();\n      const deltaTop = rect.top - customScrollParentRect.top;\n      visibleHeight = customScrollParentRect.height - Math.max(0, deltaTop);\n      offsetTop = deltaTop + customScrollParent.scrollTop;\n    } else {\n      visibleHeight = window.innerHeight - Math.max(0, rect.top);\n      offsetTop = rect.top + window.pageYOffset;\n    }\n    viewportInfo.current = {\n      offsetTop,\n      visibleHeight,\n      visibleWidth\n    };\n    callback(viewportInfo.current);\n  }, [callback, customScrollParent]);\n  const {\n    callbackRef,\n    ref\n  } = useSizeWithElRef(calculateInfo);\n  const scrollAndResizeEventHandler = React.useCallback(() => {\n    calculateInfo(ref.current);\n  }, [calculateInfo, ref]);\n  React.useEffect(() => {\n    if (customScrollParent) {\n      customScrollParent.addEventListener(\"scroll\", scrollAndResizeEventHandler);\n      const observer = new ResizeObserver(scrollAndResizeEventHandler);\n      observer.observe(customScrollParent);\n      return () => {\n        customScrollParent.removeEventListener(\"scroll\", scrollAndResizeEventHandler);\n        observer.unobserve(customScrollParent);\n      };\n    } else {\n      window.addEventListener(\"scroll\", scrollAndResizeEventHandler);\n      window.addEventListener(\"resize\", scrollAndResizeEventHandler);\n      return () => {\n        window.removeEventListener(\"scroll\", scrollAndResizeEventHandler);\n        window.removeEventListener(\"resize\", scrollAndResizeEventHandler);\n      };\n    }\n  }, [scrollAndResizeEventHandler, customScrollParent]);\n  return callbackRef;\n}\nconst VirtuosoMockContext = React.createContext(void 0);\nconst VirtuosoGridMockContext = React.createContext(void 0);\nfunction identity(value) {\n  return value;\n}\nconst listComponentPropsSystem = /* @__PURE__ */system(() => {\n  const itemContent = statefulStream(index => `Item ${index}`);\n  const context = statefulStream(null);\n  const groupContent = statefulStream(index => `Group ${index}`);\n  const components = statefulStream({});\n  const computeItemKey = statefulStream(identity);\n  const headerFooterTag = statefulStream(\"div\");\n  const scrollerRef = statefulStream(noop);\n  const distinctProp = function (propName) {\n    let defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return statefulStreamFromEmitter(pipe(components, map(components2 => components2[propName]), distinctUntilChanged()), defaultValue);\n  };\n  return {\n    context,\n    itemContent,\n    groupContent,\n    components,\n    computeItemKey,\n    headerFooterTag,\n    scrollerRef,\n    FooterComponent: distinctProp(\"Footer\"),\n    HeaderComponent: distinctProp(\"Header\"),\n    TopItemListComponent: distinctProp(\"TopItemList\"),\n    ListComponent: distinctProp(\"List\", \"div\"),\n    ItemComponent: distinctProp(\"Item\", \"div\"),\n    GroupComponent: distinctProp(\"Group\", \"div\"),\n    ScrollerComponent: distinctProp(\"Scroller\", \"div\"),\n    EmptyPlaceholder: distinctProp(\"EmptyPlaceholder\"),\n    ScrollSeekPlaceholder: distinctProp(\"ScrollSeekPlaceholder\")\n  };\n});\nconst combinedSystem$2 = /* @__PURE__ */system(_ref95 => {\n  let [listSystem2, propsSystem] = _ref95;\n  return {\n    ...listSystem2,\n    ...propsSystem\n  };\n}, tup(listSystem, listComponentPropsSystem));\nconst DefaultScrollSeekPlaceholder$1 = _ref96 => {\n  let {\n    height\n  } = _ref96;\n  return /* @__PURE__ */React.createElement(\"div\", {\n    style: {\n      height\n    }\n  });\n};\nconst GROUP_STYLE = {\n  position: positionStickyCssValue(),\n  zIndex: 1,\n  overflowAnchor: \"none\"\n};\nconst ITEM_STYLE = {\n  overflowAnchor: \"none\"\n};\nconst Items$1 = /* @__PURE__ */React.memo(function VirtuosoItems(_ref97) {\n  let {\n    showTopList = false\n  } = _ref97;\n  const listState = useEmitterValue$2(\"listState\");\n  const sizeRanges = usePublisher$2(\"sizeRanges\");\n  const useWindowScroll = useEmitterValue$2(\"useWindowScroll\");\n  const customScrollParent = useEmitterValue$2(\"customScrollParent\");\n  const windowScrollContainerStateCallback = usePublisher$2(\"windowScrollContainerState\");\n  const _scrollContainerStateCallback = usePublisher$2(\"scrollContainerState\");\n  const scrollContainerStateCallback = customScrollParent || useWindowScroll ? windowScrollContainerStateCallback : _scrollContainerStateCallback;\n  const itemContent = useEmitterValue$2(\"itemContent\");\n  const context = useEmitterValue$2(\"context\");\n  const groupContent = useEmitterValue$2(\"groupContent\");\n  const trackItemSizes = useEmitterValue$2(\"trackItemSizes\");\n  const itemSize = useEmitterValue$2(\"itemSize\");\n  const log = useEmitterValue$2(\"log\");\n  const listGap = usePublisher$2(\"gap\");\n  const {\n    callbackRef\n  } = useChangedListContentsSizes(sizeRanges, itemSize, trackItemSizes, showTopList ? noop : scrollContainerStateCallback, log, listGap, customScrollParent);\n  const [deviation, setDeviation] = React.useState(0);\n  useEmitter$2(\"deviation\", value => {\n    if (deviation !== value) {\n      setDeviation(value);\n    }\n  });\n  const EmptyPlaceholder = useEmitterValue$2(\"EmptyPlaceholder\");\n  const ScrollSeekPlaceholder = useEmitterValue$2(\"ScrollSeekPlaceholder\") || DefaultScrollSeekPlaceholder$1;\n  const ListComponent = useEmitterValue$2(\"ListComponent\");\n  const ItemComponent = useEmitterValue$2(\"ItemComponent\");\n  const GroupComponent = useEmitterValue$2(\"GroupComponent\");\n  const computeItemKey = useEmitterValue$2(\"computeItemKey\");\n  const isSeeking = useEmitterValue$2(\"isSeeking\");\n  const hasGroups2 = useEmitterValue$2(\"groupIndices\").length > 0;\n  const paddingTopAddition = useEmitterValue$2(\"paddingTopAddition\");\n  const containerStyle = showTopList ? {} : {\n    boxSizing: \"border-box\",\n    paddingTop: listState.offsetTop + paddingTopAddition,\n    paddingBottom: listState.offsetBottom,\n    marginTop: deviation\n  };\n  if (!showTopList && listState.totalCount === 0 && EmptyPlaceholder) {\n    return React.createElement(EmptyPlaceholder, contextPropIfNotDomElement(EmptyPlaceholder, context));\n  }\n  return React.createElement(ListComponent, {\n    ...contextPropIfNotDomElement(ListComponent, context),\n    ref: callbackRef,\n    style: containerStyle,\n    \"data-test-id\": showTopList ? \"virtuoso-top-item-list\" : \"virtuoso-item-list\"\n  }, (showTopList ? listState.topItems : listState.items).map(item => {\n    const index = item.originalIndex;\n    const key = computeItemKey(index + listState.firstItemIndex, item.data, context);\n    if (isSeeking) {\n      return React.createElement(ScrollSeekPlaceholder, {\n        ...contextPropIfNotDomElement(ScrollSeekPlaceholder, context),\n        key,\n        index: item.index,\n        height: item.size,\n        type: item.type || \"item\",\n        ...(item.type === \"group\" ? {} : {\n          groupIndex: item.groupIndex\n        })\n      });\n    }\n    if (item.type === \"group\") {\n      return React.createElement(GroupComponent, {\n        ...contextPropIfNotDomElement(GroupComponent, context),\n        key,\n        \"data-index\": index,\n        \"data-known-size\": item.size,\n        \"data-item-index\": item.index,\n        style: GROUP_STYLE\n      }, groupContent(item.index));\n    } else {\n      return React.createElement(ItemComponent, {\n        ...contextPropIfNotDomElement(ItemComponent, context),\n        key,\n        \"data-index\": index,\n        \"data-known-size\": item.size,\n        \"data-item-index\": item.index,\n        \"data-item-group-index\": item.groupIndex,\n        item: item.data,\n        style: ITEM_STYLE\n      }, hasGroups2 ? itemContent(item.index, item.groupIndex, item.data, context) : itemContent(item.index, item.data, context));\n    }\n  }));\n});\nconst scrollerStyle = {\n  height: \"100%\",\n  outline: \"none\",\n  overflowY: \"auto\",\n  position: \"relative\",\n  WebkitOverflowScrolling: \"touch\"\n};\nconst viewportStyle = {\n  width: \"100%\",\n  height: \"100%\",\n  position: \"absolute\",\n  top: 0\n};\nconst topItemListStyle = {\n  width: \"100%\",\n  position: positionStickyCssValue(),\n  top: 0,\n  zIndex: 1\n};\nfunction contextPropIfNotDomElement(element, context) {\n  if (typeof element === \"string\") {\n    return void 0;\n  }\n  return {\n    context\n  };\n}\nconst Header$1 = /* @__PURE__ */React.memo(function VirtuosoHeader() {\n  const Header2 = useEmitterValue$2(\"HeaderComponent\");\n  const headerHeight = usePublisher$2(\"headerHeight\");\n  const headerFooterTag = useEmitterValue$2(\"headerFooterTag\");\n  const ref = useSize(el => headerHeight(correctItemSize(el, \"height\")));\n  const context = useEmitterValue$2(\"context\");\n  return Header2 ? React.createElement(headerFooterTag, {\n    ref\n  }, React.createElement(Header2, contextPropIfNotDomElement(Header2, context))) : null;\n});\nconst Footer$1 = /* @__PURE__ */React.memo(function VirtuosoFooter() {\n  const Footer2 = useEmitterValue$2(\"FooterComponent\");\n  const footerHeight = usePublisher$2(\"footerHeight\");\n  const headerFooterTag = useEmitterValue$2(\"headerFooterTag\");\n  const ref = useSize(el => footerHeight(correctItemSize(el, \"height\")));\n  const context = useEmitterValue$2(\"context\");\n  return Footer2 ? React.createElement(headerFooterTag, {\n    ref\n  }, React.createElement(Footer2, contextPropIfNotDomElement(Footer2, context))) : null;\n});\nfunction buildScroller(_ref98) {\n  let {\n    usePublisher: usePublisher2,\n    useEmitter: useEmitter2,\n    useEmitterValue: useEmitterValue2\n  } = _ref98;\n  const Scroller2 = React.memo(function VirtuosoScroller(_ref99) {\n    let {\n      style,\n      children,\n      ...props\n    } = _ref99;\n    const scrollContainerStateCallback = usePublisher2(\"scrollContainerState\");\n    const ScrollerComponent = useEmitterValue2(\"ScrollerComponent\");\n    const smoothScrollTargetReached = usePublisher2(\"smoothScrollTargetReached\");\n    const scrollerRefCallback = useEmitterValue2(\"scrollerRef\");\n    const context = useEmitterValue2(\"context\");\n    const {\n      scrollerRef,\n      scrollByCallback,\n      scrollToCallback\n    } = useScrollTop(scrollContainerStateCallback, smoothScrollTargetReached, ScrollerComponent, scrollerRefCallback);\n    useEmitter2(\"scrollTo\", scrollToCallback);\n    useEmitter2(\"scrollBy\", scrollByCallback);\n    return React.createElement(ScrollerComponent, {\n      ref: scrollerRef,\n      style: {\n        ...scrollerStyle,\n        ...style\n      },\n      \"data-test-id\": \"virtuoso-scroller\",\n      \"data-virtuoso-scroller\": true,\n      tabIndex: 0,\n      ...props,\n      ...contextPropIfNotDomElement(ScrollerComponent, context)\n    }, children);\n  });\n  return Scroller2;\n}\nfunction buildWindowScroller(_ref100) {\n  let {\n    usePublisher: usePublisher2,\n    useEmitter: useEmitter2,\n    useEmitterValue: useEmitterValue2\n  } = _ref100;\n  const Scroller2 = React.memo(function VirtuosoWindowScroller(_ref101) {\n    let {\n      style,\n      children,\n      ...props\n    } = _ref101;\n    const scrollContainerStateCallback = usePublisher2(\"windowScrollContainerState\");\n    const ScrollerComponent = useEmitterValue2(\"ScrollerComponent\");\n    const smoothScrollTargetReached = usePublisher2(\"smoothScrollTargetReached\");\n    const totalListHeight = useEmitterValue2(\"totalListHeight\");\n    const deviation = useEmitterValue2(\"deviation\");\n    const customScrollParent = useEmitterValue2(\"customScrollParent\");\n    const context = useEmitterValue2(\"context\");\n    const {\n      scrollerRef,\n      scrollByCallback,\n      scrollToCallback\n    } = useScrollTop(scrollContainerStateCallback, smoothScrollTargetReached, ScrollerComponent, noop, customScrollParent);\n    useIsomorphicLayoutEffect$1(() => {\n      scrollerRef.current = customScrollParent ? customScrollParent : window;\n      return () => {\n        scrollerRef.current = null;\n      };\n    }, [scrollerRef, customScrollParent]);\n    useEmitter2(\"windowScrollTo\", scrollToCallback);\n    useEmitter2(\"scrollBy\", scrollByCallback);\n    return React.createElement(ScrollerComponent, {\n      style: {\n        position: \"relative\",\n        ...style,\n        ...(totalListHeight !== 0 ? {\n          height: totalListHeight + deviation\n        } : {})\n      },\n      \"data-virtuoso-scroller\": true,\n      ...props,\n      ...contextPropIfNotDomElement(ScrollerComponent, context)\n    }, children);\n  });\n  return Scroller2;\n}\nconst Viewport$2 = _ref102 => {\n  let {\n    children\n  } = _ref102;\n  const ctx = React.useContext(VirtuosoMockContext);\n  const viewportHeight = usePublisher$2(\"viewportHeight\");\n  const fixedItemHeight = usePublisher$2(\"fixedItemHeight\");\n  const viewportRef = useSize(compose(viewportHeight, el => correctItemSize(el, \"height\")));\n  React.useEffect(() => {\n    if (ctx) {\n      viewportHeight(ctx.viewportHeight);\n      fixedItemHeight(ctx.itemHeight);\n    }\n  }, [ctx, viewportHeight, fixedItemHeight]);\n  return /* @__PURE__ */React.createElement(\"div\", {\n    style: viewportStyle,\n    ref: viewportRef,\n    \"data-viewport-type\": \"element\"\n  }, children);\n};\nconst WindowViewport$2 = _ref103 => {\n  let {\n    children\n  } = _ref103;\n  const ctx = React.useContext(VirtuosoMockContext);\n  const windowViewportRect = usePublisher$2(\"windowViewportRect\");\n  const fixedItemHeight = usePublisher$2(\"fixedItemHeight\");\n  const customScrollParent = useEmitterValue$2(\"customScrollParent\");\n  const viewportRef = useWindowViewportRectRef(windowViewportRect, customScrollParent);\n  React.useEffect(() => {\n    if (ctx) {\n      fixedItemHeight(ctx.itemHeight);\n      windowViewportRect({\n        offsetTop: 0,\n        visibleHeight: ctx.viewportHeight,\n        visibleWidth: 100\n      });\n    }\n  }, [ctx, windowViewportRect, fixedItemHeight]);\n  return /* @__PURE__ */React.createElement(\"div\", {\n    ref: viewportRef,\n    style: viewportStyle,\n    \"data-viewport-type\": \"window\"\n  }, children);\n};\nconst TopItemListContainer = _ref104 => {\n  let {\n    children\n  } = _ref104;\n  const TopItemList = useEmitterValue$2(\"TopItemListComponent\");\n  const headerHeight = useEmitterValue$2(\"headerHeight\");\n  const style = {\n    ...topItemListStyle,\n    marginTop: `${headerHeight}px`\n  };\n  const context = useEmitterValue$2(\"context\");\n  return React.createElement(TopItemList || \"div\", {\n    style,\n    context\n  }, children);\n};\nconst ListRoot = /* @__PURE__ */React.memo(function VirtuosoRoot(props) {\n  const useWindowScroll = useEmitterValue$2(\"useWindowScroll\");\n  const showTopList = useEmitterValue$2(\"topItemsIndexes\").length > 0;\n  const customScrollParent = useEmitterValue$2(\"customScrollParent\");\n  const TheScroller = customScrollParent || useWindowScroll ? WindowScroller$2 : Scroller$2;\n  const TheViewport = customScrollParent || useWindowScroll ? WindowViewport$2 : Viewport$2;\n  return /* @__PURE__ */React.createElement(TheScroller, {\n    ...props\n  }, showTopList && /* @__PURE__ */React.createElement(TopItemListContainer, null, /* @__PURE__ */React.createElement(Items$1, {\n    showTopList: true\n  })), /* @__PURE__ */React.createElement(TheViewport, null, /* @__PURE__ */React.createElement(Header$1, null), /* @__PURE__ */React.createElement(Items$1, null), /* @__PURE__ */React.createElement(Footer$1, null)));\n});\nconst {\n  Component: List,\n  usePublisher: usePublisher$2,\n  useEmitterValue: useEmitterValue$2,\n  useEmitter: useEmitter$2\n} = /* @__PURE__ */systemToComponent(combinedSystem$2, {\n  required: {},\n  optional: {\n    context: \"context\",\n    followOutput: \"followOutput\",\n    firstItemIndex: \"firstItemIndex\",\n    itemContent: \"itemContent\",\n    groupContent: \"groupContent\",\n    overscan: \"overscan\",\n    increaseViewportBy: \"increaseViewportBy\",\n    totalCount: \"totalCount\",\n    topItemCount: \"topItemCount\",\n    initialTopMostItemIndex: \"initialTopMostItemIndex\",\n    components: \"components\",\n    groupCounts: \"groupCounts\",\n    atBottomThreshold: \"atBottomThreshold\",\n    atTopThreshold: \"atTopThreshold\",\n    computeItemKey: \"computeItemKey\",\n    defaultItemHeight: \"defaultItemHeight\",\n    fixedItemHeight: \"fixedItemHeight\",\n    itemSize: \"itemSize\",\n    scrollSeekConfiguration: \"scrollSeekConfiguration\",\n    headerFooterTag: \"headerFooterTag\",\n    data: \"data\",\n    initialItemCount: \"initialItemCount\",\n    initialScrollTop: \"initialScrollTop\",\n    alignToBottom: \"alignToBottom\",\n    useWindowScroll: \"useWindowScroll\",\n    customScrollParent: \"customScrollParent\",\n    scrollerRef: \"scrollerRef\",\n    logLevel: \"logLevel\"\n  },\n  methods: {\n    scrollToIndex: \"scrollToIndex\",\n    scrollIntoView: \"scrollIntoView\",\n    scrollTo: \"scrollTo\",\n    scrollBy: \"scrollBy\",\n    autoscrollToBottom: \"autoscrollToBottom\"\n  },\n  events: {\n    isScrolling: \"isScrolling\",\n    endReached: \"endReached\",\n    startReached: \"startReached\",\n    rangeChanged: \"rangeChanged\",\n    atBottomStateChange: \"atBottomStateChange\",\n    atTopStateChange: \"atTopStateChange\",\n    totalListHeightChanged: \"totalListHeightChanged\",\n    itemsRendered: \"itemsRendered\",\n    groupIndices: \"groupIndices\"\n  }\n}, ListRoot);\nconst Scroller$2 = /* @__PURE__ */buildScroller({\n  usePublisher: usePublisher$2,\n  useEmitterValue: useEmitterValue$2,\n  useEmitter: useEmitter$2\n});\nconst WindowScroller$2 = /* @__PURE__ */buildWindowScroller({\n  usePublisher: usePublisher$2,\n  useEmitterValue: useEmitterValue$2,\n  useEmitter: useEmitter$2\n});\nconst Virtuoso = List;\nconst GroupedVirtuoso = List;\nconst INITIAL_GRID_STATE = {\n  items: [],\n  offsetBottom: 0,\n  offsetTop: 0,\n  top: 0,\n  bottom: 0,\n  itemHeight: 0,\n  itemWidth: 0\n};\nconst PROBE_GRID_STATE = {\n  items: [{\n    index: 0\n  }],\n  offsetBottom: 0,\n  offsetTop: 0,\n  top: 0,\n  bottom: 0,\n  itemHeight: 0,\n  itemWidth: 0\n};\nconst {\n  round,\n  ceil,\n  floor,\n  min,\n  max\n} = Math;\nfunction buildProbeGridState(items) {\n  return {\n    ...PROBE_GRID_STATE,\n    items\n  };\n}\nfunction buildItems(startIndex, endIndex, data) {\n  return Array.from({\n    length: endIndex - startIndex + 1\n  }).map((_, i) => ({\n    index: i + startIndex,\n    data: data == null ? void 0 : data[i + startIndex]\n  }));\n}\nfunction gapComparator(prev, next) {\n  return prev && prev.column === next.column && prev.row === next.row;\n}\nfunction dimensionComparator(prev, next) {\n  return prev && prev.width === next.width && prev.height === next.height;\n}\nconst gridSystem = /* @__PURE__ */system(_ref105 => {\n  let [{\n    overscan,\n    visibleRange,\n    listBoundary\n  }, {\n    scrollTop,\n    viewportHeight,\n    scrollBy,\n    scrollTo,\n    smoothScrollTargetReached,\n    scrollContainerState,\n    footerHeight,\n    headerHeight\n  }, stateFlags, scrollSeek, {\n    propsReady,\n    didMount\n  }, {\n    windowViewportRect,\n    windowScrollTo,\n    useWindowScroll,\n    customScrollParent,\n    windowScrollContainerState\n  }, log] = _ref105;\n  const totalCount = statefulStream(0);\n  const initialItemCount = statefulStream(0);\n  const gridState = statefulStream(INITIAL_GRID_STATE);\n  const viewportDimensions = statefulStream({\n    height: 0,\n    width: 0\n  });\n  const itemDimensions = statefulStream({\n    height: 0,\n    width: 0\n  });\n  const scrollToIndex = stream();\n  const scrollHeight = stream();\n  const deviation = statefulStream(0);\n  const data = statefulStream(void 0);\n  const gap = statefulStream({\n    row: 0,\n    column: 0\n  });\n  connect(pipe(combineLatest(didMount, initialItemCount, data), filter(_ref106 => {\n    let [, count] = _ref106;\n    return count !== 0;\n  }), map(_ref107 => {\n    let [, count, data2] = _ref107;\n    return {\n      items: buildItems(0, count - 1, data2),\n      top: 0,\n      bottom: 0,\n      offsetBottom: 0,\n      offsetTop: 0,\n      itemHeight: 0,\n      itemWidth: 0\n    };\n  })), gridState);\n  connect(pipe(combineLatest(duc(totalCount), visibleRange, duc(gap, gapComparator), duc(itemDimensions, dimensionComparator), duc(viewportDimensions, dimensionComparator), data), map(_ref108 => {\n    let [totalCount2, [startOffset, endOffset], gap2, item, viewport, data2] = _ref108;\n    const {\n      row: rowGap,\n      column: columnGap\n    } = gap2;\n    const {\n      height: itemHeight,\n      width: itemWidth\n    } = item;\n    const {\n      width: viewportWidth\n    } = viewport;\n    if (totalCount2 === 0 || viewportWidth === 0) {\n      return INITIAL_GRID_STATE;\n    }\n    if (itemWidth === 0) {\n      return buildProbeGridState(buildItems(0, 0, data2));\n    }\n    const perRow = itemsPerRow(viewportWidth, itemWidth, columnGap);\n    let startIndex = perRow * floor((startOffset + rowGap) / (itemHeight + rowGap));\n    let endIndex = perRow * ceil((endOffset + rowGap) / (itemHeight + rowGap)) - 1;\n    endIndex = min(totalCount2 - 1, max(endIndex, perRow - 1));\n    startIndex = min(endIndex, max(0, startIndex));\n    const items = buildItems(startIndex, endIndex, data2);\n    const {\n      top,\n      bottom\n    } = gridLayout(viewport, gap2, item, items);\n    const rowCount = ceil(totalCount2 / perRow);\n    const totalHeight = rowCount * itemHeight + (rowCount - 1) * rowGap;\n    const offsetBottom = totalHeight - bottom;\n    return {\n      items,\n      offsetTop: top,\n      offsetBottom,\n      top,\n      bottom,\n      itemHeight,\n      itemWidth\n    };\n  })), gridState);\n  connect(pipe(data, filter(data2 => data2 !== void 0), map(data2 => data2.length)), totalCount);\n  connect(pipe(viewportDimensions, map(_ref109 => {\n    let {\n      height\n    } = _ref109;\n    return height;\n  })), viewportHeight);\n  connect(pipe(combineLatest(viewportDimensions, itemDimensions, gridState, gap), map(_ref110 => {\n    let [viewportDimensions2, item, {\n      items\n    }, gap2] = _ref110;\n    const {\n      top,\n      bottom\n    } = gridLayout(viewportDimensions2, gap2, item, items);\n    return [top, bottom];\n  }), distinctUntilChanged(tupleComparator)), listBoundary);\n  const endReached = streamFromEmitter(pipe(duc(gridState), filter(_ref111 => {\n    let {\n      items\n    } = _ref111;\n    return items.length > 0;\n  }), withLatestFrom(totalCount), filter(_ref112 => {\n    let [{\n      items\n    }, totalCount2] = _ref112;\n    return items[items.length - 1].index === totalCount2 - 1;\n  }), map(_ref113 => {\n    let [, totalCount2] = _ref113;\n    return totalCount2 - 1;\n  }), distinctUntilChanged()));\n  const startReached = streamFromEmitter(pipe(duc(gridState), filter(_ref114 => {\n    let {\n      items\n    } = _ref114;\n    return items.length > 0 && items[0].index === 0;\n  }), mapTo(0), distinctUntilChanged()));\n  const rangeChanged = streamFromEmitter(pipe(duc(gridState), filter(_ref115 => {\n    let {\n      items\n    } = _ref115;\n    return items.length > 0;\n  }), map(_ref116 => {\n    let {\n      items\n    } = _ref116;\n    return {\n      startIndex: items[0].index,\n      endIndex: items[items.length - 1].index\n    };\n  }), distinctUntilChanged(rangeComparator)));\n  connect(rangeChanged, scrollSeek.scrollSeekRangeChanged);\n  connect(pipe(scrollToIndex, withLatestFrom(viewportDimensions, itemDimensions, totalCount, gap), map(_ref117 => {\n    let [location, viewport, item, totalCount2, gap2] = _ref117;\n    const normalLocation = normalizeIndexLocation(location);\n    const {\n      align,\n      behavior,\n      offset\n    } = normalLocation;\n    let index = normalLocation.index;\n    if (index === \"LAST\") {\n      index = totalCount2 - 1;\n    }\n    index = max(0, index, min(totalCount2 - 1, index));\n    let top = itemTop(viewport, gap2, item, index);\n    if (align === \"end\") {\n      top = round(top - viewport.height + item.height);\n    } else if (align === \"center\") {\n      top = round(top - viewport.height / 2 + item.height / 2);\n    }\n    if (offset) {\n      top += offset;\n    }\n    return {\n      top,\n      behavior\n    };\n  })), scrollTo);\n  const totalListHeight = statefulStreamFromEmitter(pipe(gridState, map(gridState2 => {\n    return gridState2.offsetBottom + gridState2.bottom;\n  })), 0);\n  connect(pipe(windowViewportRect, map(viewportInfo => ({\n    width: viewportInfo.visibleWidth,\n    height: viewportInfo.visibleHeight\n  }))), viewportDimensions);\n  return {\n    data,\n    totalCount,\n    viewportDimensions,\n    itemDimensions,\n    scrollTop,\n    scrollHeight,\n    overscan,\n    scrollBy,\n    scrollTo,\n    scrollToIndex,\n    smoothScrollTargetReached,\n    windowViewportRect,\n    windowScrollTo,\n    useWindowScroll,\n    customScrollParent,\n    windowScrollContainerState,\n    deviation,\n    scrollContainerState,\n    footerHeight,\n    headerHeight,\n    initialItemCount,\n    gap,\n    ...scrollSeek,\n    gridState,\n    totalListHeight,\n    ...stateFlags,\n    startReached,\n    endReached,\n    rangeChanged,\n    propsReady,\n    ...log\n  };\n}, tup(sizeRangeSystem, domIOSystem, stateFlagsSystem, scrollSeekSystem, propsReadySystem, windowScrollerSystem, loggerSystem));\nfunction gridLayout(viewport, gap, item, items) {\n  const {\n    height: itemHeight\n  } = item;\n  if (itemHeight === void 0 || items.length === 0) {\n    return {\n      top: 0,\n      bottom: 0\n    };\n  }\n  const top = itemTop(viewport, gap, item, items[0].index);\n  const bottom = itemTop(viewport, gap, item, items[items.length - 1].index) + itemHeight;\n  return {\n    top,\n    bottom\n  };\n}\nfunction itemTop(viewport, gap, item, index) {\n  const perRow = itemsPerRow(viewport.width, item.width, gap.column);\n  const rowCount = floor(index / perRow);\n  const top = rowCount * item.height + max(0, rowCount - 1) * gap.row;\n  return top > 0 ? top + gap.row : top;\n}\nfunction itemsPerRow(viewportWidth, itemWidth, gap) {\n  return max(1, floor((viewportWidth + gap) / (itemWidth + gap)));\n}\nconst gridComponentPropsSystem = /* @__PURE__ */system(() => {\n  const itemContent = statefulStream(index => `Item ${index}`);\n  const components = statefulStream({});\n  const context = statefulStream(null);\n  const itemClassName = statefulStream(\"virtuoso-grid-item\");\n  const listClassName = statefulStream(\"virtuoso-grid-list\");\n  const computeItemKey = statefulStream(identity);\n  const headerFooterTag = statefulStream(\"div\");\n  const scrollerRef = statefulStream(noop);\n  const distinctProp = function (propName) {\n    let defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return statefulStreamFromEmitter(pipe(components, map(components2 => components2[propName]), distinctUntilChanged()), defaultValue);\n  };\n  return {\n    context,\n    itemContent,\n    components,\n    computeItemKey,\n    itemClassName,\n    listClassName,\n    headerFooterTag,\n    scrollerRef,\n    FooterComponent: distinctProp(\"Footer\"),\n    HeaderComponent: distinctProp(\"Header\"),\n    ListComponent: distinctProp(\"List\", \"div\"),\n    ItemComponent: distinctProp(\"Item\", \"div\"),\n    ScrollerComponent: distinctProp(\"Scroller\", \"div\"),\n    ScrollSeekPlaceholder: distinctProp(\"ScrollSeekPlaceholder\", \"div\")\n  };\n});\nconst combinedSystem$1 = /* @__PURE__ */system(_ref118 => {\n  let [gridSystem2, gridComponentPropsSystem2] = _ref118;\n  return {\n    ...gridSystem2,\n    ...gridComponentPropsSystem2\n  };\n}, tup(gridSystem, gridComponentPropsSystem));\nconst GridItems = /* @__PURE__ */React.memo(function GridItems2() {\n  const gridState = useEmitterValue$1(\"gridState\");\n  const listClassName = useEmitterValue$1(\"listClassName\");\n  const itemClassName = useEmitterValue$1(\"itemClassName\");\n  const itemContent = useEmitterValue$1(\"itemContent\");\n  const computeItemKey = useEmitterValue$1(\"computeItemKey\");\n  const isSeeking = useEmitterValue$1(\"isSeeking\");\n  const scrollHeightCallback = usePublisher$1(\"scrollHeight\");\n  const ItemComponent = useEmitterValue$1(\"ItemComponent\");\n  const ListComponent = useEmitterValue$1(\"ListComponent\");\n  const ScrollSeekPlaceholder = useEmitterValue$1(\"ScrollSeekPlaceholder\");\n  const context = useEmitterValue$1(\"context\");\n  const itemDimensions = usePublisher$1(\"itemDimensions\");\n  const gridGap = usePublisher$1(\"gap\");\n  const log = useEmitterValue$1(\"log\");\n  const listRef = useSize(el => {\n    const scrollHeight = el.parentElement.parentElement.scrollHeight;\n    scrollHeightCallback(scrollHeight);\n    const firstItem = el.firstChild;\n    if (firstItem) {\n      itemDimensions(firstItem.getBoundingClientRect());\n    }\n    gridGap({\n      row: resolveGapValue(\"row-gap\", getComputedStyle(el).rowGap, log),\n      column: resolveGapValue(\"column-gap\", getComputedStyle(el).columnGap, log)\n    });\n  });\n  return React.createElement(ListComponent, {\n    ref: listRef,\n    className: listClassName,\n    ...contextPropIfNotDomElement(ListComponent, context),\n    style: {\n      paddingTop: gridState.offsetTop,\n      paddingBottom: gridState.offsetBottom\n    },\n    \"data-test-id\": \"virtuoso-item-list\"\n  }, gridState.items.map(item => {\n    const key = computeItemKey(item.index, item.data, context);\n    return isSeeking ? React.createElement(ScrollSeekPlaceholder, {\n      key,\n      ...contextPropIfNotDomElement(ScrollSeekPlaceholder, context),\n      index: item.index,\n      height: gridState.itemHeight,\n      width: gridState.itemWidth\n    }) : React.createElement(ItemComponent, {\n      ...contextPropIfNotDomElement(ItemComponent, context),\n      className: itemClassName,\n      \"data-index\": item.index,\n      key\n    }, itemContent(item.index, item.data, context));\n  }));\n});\nconst Header = React.memo(function VirtuosoHeader2() {\n  const Header2 = useEmitterValue$1(\"HeaderComponent\");\n  const headerHeight = usePublisher$1(\"headerHeight\");\n  const headerFooterTag = useEmitterValue$1(\"headerFooterTag\");\n  const ref = useSize(el => headerHeight(correctItemSize(el, \"height\")));\n  const context = useEmitterValue$1(\"context\");\n  return Header2 ? React.createElement(headerFooterTag, {\n    ref\n  }, React.createElement(Header2, contextPropIfNotDomElement(Header2, context))) : null;\n});\nconst Footer = React.memo(function VirtuosoGridFooter() {\n  const Footer2 = useEmitterValue$1(\"FooterComponent\");\n  const footerHeight = usePublisher$1(\"footerHeight\");\n  const headerFooterTag = useEmitterValue$1(\"headerFooterTag\");\n  const ref = useSize(el => footerHeight(correctItemSize(el, \"height\")));\n  const context = useEmitterValue$1(\"context\");\n  return Footer2 ? React.createElement(headerFooterTag, {\n    ref\n  }, React.createElement(Footer2, contextPropIfNotDomElement(Footer2, context))) : null;\n});\nconst Viewport$1 = _ref119 => {\n  let {\n    children\n  } = _ref119;\n  const ctx = React.useContext(VirtuosoGridMockContext);\n  const itemDimensions = usePublisher$1(\"itemDimensions\");\n  const viewportDimensions = usePublisher$1(\"viewportDimensions\");\n  const viewportRef = useSize(el => {\n    viewportDimensions(el.getBoundingClientRect());\n  });\n  React.useEffect(() => {\n    if (ctx) {\n      viewportDimensions({\n        height: ctx.viewportHeight,\n        width: ctx.viewportWidth\n      });\n      itemDimensions({\n        height: ctx.itemHeight,\n        width: ctx.itemWidth\n      });\n    }\n  }, [ctx, viewportDimensions, itemDimensions]);\n  return /* @__PURE__ */React.createElement(\"div\", {\n    style: viewportStyle,\n    ref: viewportRef\n  }, children);\n};\nconst WindowViewport$1 = _ref120 => {\n  let {\n    children\n  } = _ref120;\n  const ctx = React.useContext(VirtuosoGridMockContext);\n  const windowViewportRect = usePublisher$1(\"windowViewportRect\");\n  const itemDimensions = usePublisher$1(\"itemDimensions\");\n  const customScrollParent = useEmitterValue$1(\"customScrollParent\");\n  const viewportRef = useWindowViewportRectRef(windowViewportRect, customScrollParent);\n  React.useEffect(() => {\n    if (ctx) {\n      itemDimensions({\n        height: ctx.itemHeight,\n        width: ctx.itemWidth\n      });\n      windowViewportRect({\n        offsetTop: 0,\n        visibleHeight: ctx.viewportHeight,\n        visibleWidth: ctx.viewportWidth\n      });\n    }\n  }, [ctx, windowViewportRect, itemDimensions]);\n  return /* @__PURE__ */React.createElement(\"div\", {\n    ref: viewportRef,\n    style: viewportStyle\n  }, children);\n};\nconst GridRoot = /* @__PURE__ */React.memo(function GridRoot2(_ref121) {\n  let {\n    ...props\n  } = _ref121;\n  const useWindowScroll = useEmitterValue$1(\"useWindowScroll\");\n  const customScrollParent = useEmitterValue$1(\"customScrollParent\");\n  const TheScroller = customScrollParent || useWindowScroll ? WindowScroller$1 : Scroller$1;\n  const TheViewport = customScrollParent || useWindowScroll ? WindowViewport$1 : Viewport$1;\n  return /* @__PURE__ */React.createElement(TheScroller, {\n    ...props\n  }, /* @__PURE__ */React.createElement(TheViewport, null, /* @__PURE__ */React.createElement(Header, null), /* @__PURE__ */React.createElement(GridItems, null), /* @__PURE__ */React.createElement(Footer, null)));\n});\nconst {\n  Component: Grid,\n  usePublisher: usePublisher$1,\n  useEmitterValue: useEmitterValue$1,\n  useEmitter: useEmitter$1\n} = /* @__PURE__ */systemToComponent(combinedSystem$1, {\n  optional: {\n    context: \"context\",\n    totalCount: \"totalCount\",\n    overscan: \"overscan\",\n    itemContent: \"itemContent\",\n    components: \"components\",\n    computeItemKey: \"computeItemKey\",\n    data: \"data\",\n    initialItemCount: \"initialItemCount\",\n    scrollSeekConfiguration: \"scrollSeekConfiguration\",\n    headerFooterTag: \"headerFooterTag\",\n    listClassName: \"listClassName\",\n    itemClassName: \"itemClassName\",\n    useWindowScroll: \"useWindowScroll\",\n    customScrollParent: \"customScrollParent\",\n    scrollerRef: \"scrollerRef\"\n  },\n  methods: {\n    scrollTo: \"scrollTo\",\n    scrollBy: \"scrollBy\",\n    scrollToIndex: \"scrollToIndex\"\n  },\n  events: {\n    isScrolling: \"isScrolling\",\n    endReached: \"endReached\",\n    startReached: \"startReached\",\n    rangeChanged: \"rangeChanged\",\n    atBottomStateChange: \"atBottomStateChange\",\n    atTopStateChange: \"atTopStateChange\"\n  }\n}, GridRoot);\nconst Scroller$1 = /* @__PURE__ */buildScroller({\n  usePublisher: usePublisher$1,\n  useEmitterValue: useEmitterValue$1,\n  useEmitter: useEmitter$1\n});\nconst WindowScroller$1 = /* @__PURE__ */buildWindowScroller({\n  usePublisher: usePublisher$1,\n  useEmitterValue: useEmitterValue$1,\n  useEmitter: useEmitter$1\n});\nfunction resolveGapValue(property, value, log) {\n  if (value !== \"normal\" && !(value == null ? void 0 : value.endsWith(\"px\"))) {\n    log(`${property} was not resolved to pixel value correctly`, value, LogLevel.WARN);\n  }\n  if (value === \"normal\") {\n    return 0;\n  }\n  return parseInt(value ?? \"0\", 10);\n}\nconst VirtuosoGrid = Grid;\nconst tableComponentPropsSystem = /* @__PURE__ */system(() => {\n  const itemContent = statefulStream(index => /* @__PURE__ */React.createElement(\"td\", null, \"Item $\", index));\n  const context = statefulStream(null);\n  const fixedHeaderContent = statefulStream(null);\n  const fixedFooterContent = statefulStream(null);\n  const components = statefulStream({});\n  const computeItemKey = statefulStream(identity);\n  const scrollerRef = statefulStream(noop);\n  const distinctProp = function (propName) {\n    let defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return statefulStreamFromEmitter(pipe(components, map(components2 => components2[propName]), distinctUntilChanged()), defaultValue);\n  };\n  return {\n    context,\n    itemContent,\n    fixedHeaderContent,\n    fixedFooterContent,\n    components,\n    computeItemKey,\n    scrollerRef,\n    TableComponent: distinctProp(\"Table\", \"table\"),\n    TableHeadComponent: distinctProp(\"TableHead\", \"thead\"),\n    TableFooterComponent: distinctProp(\"TableFoot\", \"tfoot\"),\n    TableBodyComponent: distinctProp(\"TableBody\", \"tbody\"),\n    TableRowComponent: distinctProp(\"TableRow\", \"tr\"),\n    ScrollerComponent: distinctProp(\"Scroller\", \"div\"),\n    EmptyPlaceholder: distinctProp(\"EmptyPlaceholder\"),\n    ScrollSeekPlaceholder: distinctProp(\"ScrollSeekPlaceholder\"),\n    FillerRow: distinctProp(\"FillerRow\")\n  };\n});\nconst combinedSystem = /* @__PURE__ */system(_ref122 => {\n  let [listSystem2, propsSystem] = _ref122;\n  return {\n    ...listSystem2,\n    ...propsSystem\n  };\n}, tup(listSystem, tableComponentPropsSystem));\nconst DefaultScrollSeekPlaceholder = _ref123 => {\n  let {\n    height\n  } = _ref123;\n  return /* @__PURE__ */React.createElement(\"tr\", null, /* @__PURE__ */React.createElement(\"td\", {\n    style: {\n      height\n    }\n  }));\n};\nconst DefaultFillerRow = _ref124 => {\n  let {\n    height\n  } = _ref124;\n  return /* @__PURE__ */React.createElement(\"tr\", null, /* @__PURE__ */React.createElement(\"td\", {\n    style: {\n      height,\n      padding: 0,\n      border: 0\n    }\n  }));\n};\nconst Items = /* @__PURE__ */React.memo(function VirtuosoItems2() {\n  const listState = useEmitterValue(\"listState\");\n  const sizeRanges = usePublisher(\"sizeRanges\");\n  const useWindowScroll = useEmitterValue(\"useWindowScroll\");\n  const customScrollParent = useEmitterValue(\"customScrollParent\");\n  const windowScrollContainerStateCallback = usePublisher(\"windowScrollContainerState\");\n  const _scrollContainerStateCallback = usePublisher(\"scrollContainerState\");\n  const scrollContainerStateCallback = customScrollParent || useWindowScroll ? windowScrollContainerStateCallback : _scrollContainerStateCallback;\n  const itemContent = useEmitterValue(\"itemContent\");\n  const trackItemSizes = useEmitterValue(\"trackItemSizes\");\n  const itemSize = useEmitterValue(\"itemSize\");\n  const log = useEmitterValue(\"log\");\n  const {\n    callbackRef,\n    ref\n  } = useChangedListContentsSizes(sizeRanges, itemSize, trackItemSizes, scrollContainerStateCallback, log, void 0, customScrollParent);\n  const [deviation, setDeviation] = React.useState(0);\n  useEmitter(\"deviation\", value => {\n    if (deviation !== value) {\n      ref.current.style.marginTop = `${value}px`;\n      setDeviation(value);\n    }\n  });\n  const EmptyPlaceholder = useEmitterValue(\"EmptyPlaceholder\");\n  const ScrollSeekPlaceholder = useEmitterValue(\"ScrollSeekPlaceholder\") || DefaultScrollSeekPlaceholder;\n  const FillerRow = useEmitterValue(\"FillerRow\") || DefaultFillerRow;\n  const TableBodyComponent = useEmitterValue(\"TableBodyComponent\");\n  const TableRowComponent = useEmitterValue(\"TableRowComponent\");\n  const computeItemKey = useEmitterValue(\"computeItemKey\");\n  const isSeeking = useEmitterValue(\"isSeeking\");\n  const paddingTopAddition = useEmitterValue(\"paddingTopAddition\");\n  const firstItemIndex = useEmitterValue(\"firstItemIndex\");\n  const statefulTotalCount = useEmitterValue(\"statefulTotalCount\");\n  const context = useEmitterValue(\"context\");\n  if (statefulTotalCount === 0 && EmptyPlaceholder) {\n    return React.createElement(EmptyPlaceholder, contextPropIfNotDomElement(EmptyPlaceholder, context));\n  }\n  const paddingTop = listState.offsetTop + paddingTopAddition + deviation;\n  const paddingBottom = listState.offsetBottom;\n  const paddingTopEl = paddingTop > 0 ? /* @__PURE__ */React.createElement(FillerRow, {\n    height: paddingTop,\n    key: \"padding-top\",\n    context\n  }) : null;\n  const paddingBottomEl = paddingBottom > 0 ? /* @__PURE__ */React.createElement(FillerRow, {\n    height: paddingBottom,\n    key: \"padding-bottom\",\n    context\n  }) : null;\n  const items = listState.items.map(item => {\n    const index = item.originalIndex;\n    const key = computeItemKey(index + firstItemIndex, item.data, context);\n    if (isSeeking) {\n      return React.createElement(ScrollSeekPlaceholder, {\n        ...contextPropIfNotDomElement(ScrollSeekPlaceholder, context),\n        key,\n        index: item.index,\n        height: item.size,\n        type: item.type || \"item\"\n      });\n    }\n    return React.createElement(TableRowComponent, {\n      ...contextPropIfNotDomElement(TableRowComponent, context),\n      key,\n      \"data-index\": index,\n      \"data-known-size\": item.size,\n      \"data-item-index\": item.index,\n      item: item.data,\n      style: {\n        overflowAnchor: \"none\"\n      }\n    }, itemContent(item.index, item.data, context));\n  });\n  return React.createElement(TableBodyComponent, {\n    ref: callbackRef,\n    \"data-test-id\": \"virtuoso-item-list\",\n    ...contextPropIfNotDomElement(TableBodyComponent, context)\n  }, [paddingTopEl, ...items, paddingBottomEl]);\n});\nconst Viewport = _ref125 => {\n  let {\n    children\n  } = _ref125;\n  const ctx = React.useContext(VirtuosoMockContext);\n  const viewportHeight = usePublisher(\"viewportHeight\");\n  const fixedItemHeight = usePublisher(\"fixedItemHeight\");\n  const viewportRef = useSize(compose(viewportHeight, el => correctItemSize(el, \"height\")));\n  React.useEffect(() => {\n    if (ctx) {\n      viewportHeight(ctx.viewportHeight);\n      fixedItemHeight(ctx.itemHeight);\n    }\n  }, [ctx, viewportHeight, fixedItemHeight]);\n  return /* @__PURE__ */React.createElement(\"div\", {\n    style: viewportStyle,\n    ref: viewportRef,\n    \"data-viewport-type\": \"element\"\n  }, children);\n};\nconst WindowViewport = _ref126 => {\n  let {\n    children\n  } = _ref126;\n  const ctx = React.useContext(VirtuosoMockContext);\n  const windowViewportRect = usePublisher(\"windowViewportRect\");\n  const fixedItemHeight = usePublisher(\"fixedItemHeight\");\n  const customScrollParent = useEmitterValue(\"customScrollParent\");\n  const viewportRef = useWindowViewportRectRef(windowViewportRect, customScrollParent);\n  React.useEffect(() => {\n    if (ctx) {\n      fixedItemHeight(ctx.itemHeight);\n      windowViewportRect({\n        offsetTop: 0,\n        visibleHeight: ctx.viewportHeight,\n        visibleWidth: 100\n      });\n    }\n  }, [ctx, windowViewportRect, fixedItemHeight]);\n  return /* @__PURE__ */React.createElement(\"div\", {\n    ref: viewportRef,\n    style: viewportStyle,\n    \"data-viewport-type\": \"window\"\n  }, children);\n};\nconst TableRoot = /* @__PURE__ */React.memo(function TableVirtuosoRoot(props) {\n  const useWindowScroll = useEmitterValue(\"useWindowScroll\");\n  const customScrollParent = useEmitterValue(\"customScrollParent\");\n  const fixedHeaderHeight = usePublisher(\"fixedHeaderHeight\");\n  const fixedFooterHeight = usePublisher(\"fixedFooterHeight\");\n  const fixedHeaderContent = useEmitterValue(\"fixedHeaderContent\");\n  const fixedFooterContent = useEmitterValue(\"fixedFooterContent\");\n  const context = useEmitterValue(\"context\");\n  const theadRef = useSize(compose(fixedHeaderHeight, el => correctItemSize(el, \"height\")));\n  const tfootRef = useSize(compose(fixedFooterHeight, el => correctItemSize(el, \"height\")));\n  const TheScroller = customScrollParent || useWindowScroll ? WindowScroller : Scroller;\n  const TheViewport = customScrollParent || useWindowScroll ? WindowViewport : Viewport;\n  const TheTable = useEmitterValue(\"TableComponent\");\n  const TheTHead = useEmitterValue(\"TableHeadComponent\");\n  const TheTFoot = useEmitterValue(\"TableFooterComponent\");\n  const theHead = fixedHeaderContent ? React.createElement(TheTHead, {\n    key: \"TableHead\",\n    style: {\n      zIndex: 1,\n      position: \"sticky\",\n      top: 0\n    },\n    ref: theadRef,\n    ...contextPropIfNotDomElement(TheTHead, context)\n  }, fixedHeaderContent()) : null;\n  const theFoot = fixedFooterContent ? React.createElement(TheTFoot, {\n    key: \"TableFoot\",\n    style: {\n      zIndex: 1,\n      position: \"sticky\",\n      bottom: 0\n    },\n    ref: tfootRef,\n    ...contextPropIfNotDomElement(TheTFoot, context)\n  }, fixedFooterContent()) : null;\n  return /* @__PURE__ */React.createElement(TheScroller, {\n    ...props\n  }, /* @__PURE__ */React.createElement(TheViewport, null, React.createElement(TheTable, {\n    style: {\n      borderSpacing: 0\n    },\n    ...contextPropIfNotDomElement(TheTable, context)\n  }, [theHead, /* @__PURE__ */React.createElement(Items, {\n    key: \"TableBody\"\n  }), theFoot])));\n});\nconst {\n  Component: Table,\n  usePublisher,\n  useEmitterValue,\n  useEmitter\n} = /* @__PURE__ */systemToComponent(combinedSystem, {\n  required: {},\n  optional: {\n    context: \"context\",\n    followOutput: \"followOutput\",\n    firstItemIndex: \"firstItemIndex\",\n    itemContent: \"itemContent\",\n    fixedHeaderContent: \"fixedHeaderContent\",\n    fixedFooterContent: \"fixedFooterContent\",\n    overscan: \"overscan\",\n    increaseViewportBy: \"increaseViewportBy\",\n    totalCount: \"totalCount\",\n    topItemCount: \"topItemCount\",\n    initialTopMostItemIndex: \"initialTopMostItemIndex\",\n    components: \"components\",\n    groupCounts: \"groupCounts\",\n    atBottomThreshold: \"atBottomThreshold\",\n    atTopThreshold: \"atTopThreshold\",\n    computeItemKey: \"computeItemKey\",\n    defaultItemHeight: \"defaultItemHeight\",\n    fixedItemHeight: \"fixedItemHeight\",\n    itemSize: \"itemSize\",\n    scrollSeekConfiguration: \"scrollSeekConfiguration\",\n    data: \"data\",\n    initialItemCount: \"initialItemCount\",\n    initialScrollTop: \"initialScrollTop\",\n    alignToBottom: \"alignToBottom\",\n    useWindowScroll: \"useWindowScroll\",\n    customScrollParent: \"customScrollParent\",\n    scrollerRef: \"scrollerRef\",\n    logLevel: \"logLevel\"\n  },\n  methods: {\n    scrollToIndex: \"scrollToIndex\",\n    scrollIntoView: \"scrollIntoView\",\n    scrollTo: \"scrollTo\",\n    scrollBy: \"scrollBy\"\n  },\n  events: {\n    isScrolling: \"isScrolling\",\n    endReached: \"endReached\",\n    startReached: \"startReached\",\n    rangeChanged: \"rangeChanged\",\n    atBottomStateChange: \"atBottomStateChange\",\n    atTopStateChange: \"atTopStateChange\",\n    totalListHeightChanged: \"totalListHeightChanged\",\n    itemsRendered: \"itemsRendered\",\n    groupIndices: \"groupIndices\"\n  }\n}, TableRoot);\nconst Scroller = /* @__PURE__ */buildScroller({\n  usePublisher,\n  useEmitterValue,\n  useEmitter\n});\nconst WindowScroller = /* @__PURE__ */buildWindowScroller({\n  usePublisher,\n  useEmitterValue,\n  useEmitter\n});\nconst TableVirtuoso = Table;\nexport { GroupedVirtuoso, LogLevel, TableVirtuoso, Virtuoso, VirtuosoGrid, VirtuosoGridMockContext, VirtuosoMockContext };","map":{"version":3,"names":["React","ReactDOM","PUBLISH","SUBSCRIBE","RESET","VALUE","compose","a","b","arg","thrush","proc","curry2to1","arg1","arg2","curry1to0","tap","tup","args","call","always","value","joinProc","procs","map","noop","subscribe","emitter","subscription","publish","publisher","reset","getValue","depot","connect","handleNext","unsub","stream","subscriptions","action","splice","length","push","indexOf","slice","forEach","Error","statefulStream","initial","innerSubject","eventHandler","currentSubscription","cleanup","streamFromEmitter","stream2","statefulStreamFromEmitter","combineOperators","operators","subscriber","reduceRight","pipe","source","project","defaultComparator","previous","next","distinctUntilChanged","comparator","current","done","filter","predicate","mapTo","scan","scanner","skip","times","throttleTime","interval","currentValue","timeout","setTimeout","debounceTime","clearTimeout","withLatestFrom","sources","values","Array","called","pendingCall","allCalled","Math","pow","index","bit","prevCalled","call2","concat","merge","duc","combineLatest","emitters","system","constructor","dependencies","singleton","id","Symbol","init","systemSpec","singletons","Map","_init","id2","has","get","system2","e","set","omit","keys","obj","result","idx","len","prop","hasOwnProperty","useIsomorphicLayoutEffect$2","document","useLayoutEffect","useEffect","systemToComponent","map2","Root","requiredPropNames","Object","required","optionalPropNames","optional","methodNames","methods","eventNames","events","Context","createContext","applyPropsToSystem","props","requiredPropName","optionalPropName","buildMethods","reduce","acc","methodName","buildEventHandlers","handlers","eventName","Component","forwardRef","propsWithChildren","ref","children","useState","system22","useImperativeHandle","createElement","Provider","usePublisher2","key","useCallback","useContext","useEmitterValue2","setValue","useEmitter2","callback","context","usePublisher","useEmitterValue","useEmitter","useIsomorphicLayoutEffect","useIsomorphicLayoutEffect$1","LogLevel","LogLevel2","CONSOLE_METHOD_MAP","getGlobalThis","globalThis","window","loggerSystem","logLevel","log","label","message","level","currentLevel","console","useSizeWithElRef","enabled","useRef","callbackRef","_el","ResizeObserver","observer","entries","element","target","offsetParent","elRef","observe","unobserve","useSize","useChangedListContentsSizes","itemSize","scrollContainerStateCallback","gap","customScrollParent","el","ranges","getChangedChildSizes","scrollableElement","parentElement","dataset","windowScrolling","lastElementChild","scrollTop","pageYOffset","documentElement","scrollHeight","viewportHeight","offsetHeight","innerHeight","max","resolveGapValue$1","getComputedStyle","rowGap","field","results","i","child","item","parseInt","knownSize","parseFloat","size","ERROR","lastResult","endIndex","startIndex","property","endsWith","WARN","correctItemSize","dimension","round","getBoundingClientRect","approximatelyEqual","num1","num2","abs","useScrollTop","smoothScrollTargetReached","scrollerElement","scrollerRefCallback","scrollerRef","scrollTopTarget","timeoutRef","handler","ev","windowScroll","suppressFlushSync","flushSync","localRef","addEventListener","passive","removeEventListener","scrollToCallback","location","scrollerElement2","isSmooth","behavior","maxScrollTop","top","ceil","min","scrollTo","scrollByCallback","scrollBy","domIOSystem","scrollContainerState","deviation","statefulScrollTop","headerHeight","fixedHeaderHeight","fixedFooterHeight","footerHeight","scrollingInProgress","scrollTop2","scrollHeight2","NIL_NODE","lvl","newAANode","k","v","l","r","empty","node","newTree","remove","lastKey","lastValue","last","adjust","clone","deleteLast","findMaxKeyValue","Infinity","insert","rebalance","walkWithin","start","end","walk","isSingle","split","skew","rl","rlvl","rangesWithin","adjustedStart","toRanges","arrayToRanges","items","parser","nextIndex","nextValue","nodes","findIndexOfClosestSmallerOrEqual","floor","match","join","findClosestSmallerOrEqual","findRange","startValue","endValue","recalcSystem","recalcInProgress","rangeIncludes","refRange","range","insertRanges","sizeTree","syncStart","overlappingRanges","some","firstPassDone","shouldInsert","rangeStart","rangeEnd","rangeValue","initialSizeState","offsetTree","groupOffsetTree","lastIndex","lastOffset","lastSize","groupIndices","indexComparator","itemIndex","offsetComparator","offset","itemOffset","offsetPointParser","point","rangesWithinOffsets","tree","startOffset","endOffset","minStartIndex","createOffsetTree","prevOffsetTree","prevIndex","prevSize","prevOffset","offsetInfo","kv","startIndex2","indexOffset","aOffset","sizeStateReducer","state","DEBUG","newSizeTree","groupSize","groupIndex","newOffsetTree","offsetOf","itemCount","isGroupLocation","originalIndexFromLocation","sizes","numericIndex","originalIndexFromItemIndex","hasGroups","groupOffset","SIZE_MAP","offsetWidth","sizeSystem","sizeRanges","totalCount","statefulTotalCount","unshiftWith","shiftWith","firstItemIndex","fixedItemSize","defaultItemSize","data","indexes","groupIndices2","sizes2","gap2","totalCount2","trackItemSizes","listRefresh","oldSizes","_","newSizes","changed","prev","diff","val","log2","beforeUnshiftWith","unshiftWith2","shiftWithOffset","shiftWith2","newFirstItemIndex","SUPPORTS_SCROLL_TO_OPTIONS","style","normalizeIndexLocation","align","scrollToIndexSystem","scrollToIndex","topListHeight","unsubscribeNextListRefresh","cleartTimeoutRef","unsubscribeListRefresh","viewportHeight2","topListHeight2","headerHeight2","footerHeight2","fixedHeaderHeight2","fixedFooterHeight2","normalLocation","retry","listChanged","watchChangesFor","limit","UP","DOWN","NONE$1","INITIAL_BOTTOM_STATE","atBottom","notAtBottomBecause","offsetBottom","DEFAULT_AT_TOP_THRESHOLD","stateFlagsSystem","isAtBottom","isAtTop","atBottomStateChange","atTopStateChange","atBottomThreshold","atTopThreshold","isScrolling","isScrollingBy","atTopThreshold2","atBottomState","_headerHeight","_footerHeight","atBottomThreshold2","isAtBottom2","atBottomBecause","scrollTopDelta","lastJumpDueToItemResize","jump","scrollDirection","direction","prevScrollTop","scrollVelocity","isScrolling2","propsReadySystem","propsReady","didMount","ready","getInitialTopMostItemIndexNumber","initialTopMostItemIndexSystem","scrolledToInitialItem","initialTopMostItemIndex","didMount2","scrolledToInitialItem2","defaultItemSize2","initialTopMostItemIndex2","normalizeFollowOutput","follow","behaviorFromFollowOutput","followOutputSystem","followOutput","autoscrollToBottom","pendingScrollHandle","scrollToBottom","followOutputBehavior","followOutput2","scrollingInProgress2","shouldFollow","trapNextSizeIncrease","cancel","refreshed","groupCountsToIndicesAndCount","counts","groupCount","groupedListSystem","groupCounts","topItemsIndexes","groupIndicesAndCount","tupleComparator","rangeComparator","TOP","BOTTOM","NONE","getOverscan","overscan","main","reverse","getViewportIncrease","sizeRangeSystem","listBoundary","increaseViewportBy","visibleRange","listTop","listBottom","overscan2","deviation2","increaseViewportBy2","stickyHeaderHeight","headerVisible","topViewportAddition","bottomViewportAddition","probeItemSet","EMPTY_LIST_STATE","topItems","offsetTop","bottom","transposeItems","originalIndex","transposedItems","groupRanges","currentRange","currentGroupIndex","shift","transposedItem","type","buildListState","lastItem","total","height","listStateSystem","groupedListSystem2","rangeTopListHeight","stateFlags","itemsRendered","listState","mount","recalcInProgress2","data2","dataChangeInProgress","topItemsIndexes2","firstItemIndex2","sizesValue","rangeStartIndex","rangeEndIndex","offsetPointRanges","maxIndex","endReached","count","startReached","rangeChanged","initialItemCountSystem","initialItemCount","includedGroupsCount","adjustedCount","from","scrollSeekSystem","isSeeking","scrollSeekConfiguration","config","speed","isSeeking2","exit","enter","velocity","change","scrollSeekRangeChanged","topItemCountSystem","topItemCount","totalListHeightSystem","totalListHeightChanged","totalListHeight","listState2","simpleMemoize","func","isMobileSafari","test","navigator","userAgent","upwardScrollFixSystem","deviationOffset","prevItems","prevTotalCount","prevTotalHeight","lastJumpDueToItemResize2","totalHeight","newDev","atStart","amount","scrollDirection2","scrollByWith","deviationAmount","is","recalc","requestAnimationFrame","initialScrollTopSystem","initialScrollTop","alignToBottomSystem","alignToBottom","paddingTopAddition","totalListHeight2","windowScrollerSystem","windowScrollContainerState","windowViewportRect","windowScrollTo","useWindowScroll","windowScrollTop","scrollTo2","scrollIntoViewSystem","scrollIntoView","viewLocation","rest","actualIndex","itemTop2","itemBottom","featureGroup1System","sizeRange","scrollSeek","initialScrollTopSystem2","windowScroller","listSystem","domIO","flags","featureGroup1","visibleHeight","fixedItemHeight","defaultItemHeight","WEBKIT_STICKY","STICKY","positionStickyCssValue","position","useWindowViewportRectRef","viewportInfo","calculateInfo","rect","visibleWidth","width","customScrollParentRect","deltaTop","scrollAndResizeEventHandler","VirtuosoMockContext","VirtuosoGridMockContext","identity","listComponentPropsSystem","itemContent","groupContent","components","computeItemKey","headerFooterTag","distinctProp","propName","defaultValue","components2","FooterComponent","HeaderComponent","TopItemListComponent","ListComponent","ItemComponent","GroupComponent","ScrollerComponent","EmptyPlaceholder","ScrollSeekPlaceholder","combinedSystem$2","listSystem2","propsSystem","DefaultScrollSeekPlaceholder$1","GROUP_STYLE","zIndex","overflowAnchor","ITEM_STYLE","Items$1","memo","VirtuosoItems","showTopList","useEmitterValue$2","usePublisher$2","windowScrollContainerStateCallback","_scrollContainerStateCallback","listGap","setDeviation","useEmitter$2","hasGroups2","containerStyle","boxSizing","paddingTop","paddingBottom","marginTop","contextPropIfNotDomElement","scrollerStyle","outline","overflowY","WebkitOverflowScrolling","viewportStyle","topItemListStyle","Header$1","VirtuosoHeader","Header2","Footer$1","VirtuosoFooter","Footer2","buildScroller","Scroller2","VirtuosoScroller","tabIndex","buildWindowScroller","VirtuosoWindowScroller","Viewport$2","ctx","viewportRef","itemHeight","WindowViewport$2","TopItemListContainer","TopItemList","ListRoot","VirtuosoRoot","TheScroller","WindowScroller$2","Scroller$2","TheViewport","List","Virtuoso","GroupedVirtuoso","INITIAL_GRID_STATE","itemWidth","PROBE_GRID_STATE","buildProbeGridState","buildItems","gapComparator","column","row","dimensionComparator","gridSystem","gridState","viewportDimensions","itemDimensions","viewport","columnGap","viewportWidth","perRow","itemsPerRow","gridLayout","rowCount","viewportDimensions2","itemTop","gridState2","gridComponentPropsSystem","itemClassName","listClassName","combinedSystem$1","gridSystem2","gridComponentPropsSystem2","GridItems","GridItems2","useEmitterValue$1","scrollHeightCallback","usePublisher$1","gridGap","listRef","firstItem","firstChild","resolveGapValue","className","Header","VirtuosoHeader2","Footer","VirtuosoGridFooter","Viewport$1","WindowViewport$1","GridRoot","GridRoot2","WindowScroller$1","Scroller$1","Grid","useEmitter$1","VirtuosoGrid","tableComponentPropsSystem","fixedHeaderContent","fixedFooterContent","TableComponent","TableHeadComponent","TableFooterComponent","TableBodyComponent","TableRowComponent","FillerRow","combinedSystem","DefaultScrollSeekPlaceholder","DefaultFillerRow","padding","border","Items","VirtuosoItems2","paddingTopEl","paddingBottomEl","Viewport","WindowViewport","TableRoot","TableVirtuosoRoot","theadRef","tfootRef","WindowScroller","Scroller","TheTable","TheTHead","TheTFoot","theHead","theFoot","borderSpacing","Table","TableVirtuoso"],"sources":["C:/Users/Kfirt/WebstormProjects/fed-cost-manager/node_modules/react-virtuoso/dist/index.mjs"],"sourcesContent":["import React from \"react\";\nimport ReactDOM from \"react-dom\";\nconst PUBLISH = 0;\nconst SUBSCRIBE = 1;\nconst RESET = 2;\nconst VALUE = 4;\nfunction compose(a, b) {\n  return (arg) => a(b(arg));\n}\nfunction thrush(arg, proc) {\n  return proc(arg);\n}\nfunction curry2to1(proc, arg1) {\n  return (arg2) => proc(arg1, arg2);\n}\nfunction curry1to0(proc, arg) {\n  return () => proc(arg);\n}\nfunction tap(arg, proc) {\n  proc(arg);\n  return arg;\n}\nfunction tup(...args) {\n  return args;\n}\nfunction call(proc) {\n  proc();\n}\nfunction always(value) {\n  return () => value;\n}\nfunction joinProc(...procs) {\n  return () => {\n    procs.map(call);\n  };\n}\nfunction noop() {\n}\nfunction subscribe(emitter, subscription) {\n  return emitter(SUBSCRIBE, subscription);\n}\nfunction publish(publisher, value) {\n  publisher(PUBLISH, value);\n}\nfunction reset(emitter) {\n  emitter(RESET);\n}\nfunction getValue(depot) {\n  return depot(VALUE);\n}\nfunction connect(emitter, publisher) {\n  return subscribe(emitter, curry2to1(publisher, PUBLISH));\n}\nfunction handleNext(emitter, subscription) {\n  const unsub = emitter(SUBSCRIBE, (value) => {\n    unsub();\n    subscription(value);\n  });\n  return unsub;\n}\nfunction stream() {\n  const subscriptions = [];\n  return (action, arg) => {\n    switch (action) {\n      case RESET:\n        subscriptions.splice(0, subscriptions.length);\n        return;\n      case SUBSCRIBE:\n        subscriptions.push(arg);\n        return () => {\n          const indexOf = subscriptions.indexOf(arg);\n          if (indexOf > -1) {\n            subscriptions.splice(indexOf, 1);\n          }\n        };\n      case PUBLISH:\n        subscriptions.slice().forEach((subscription) => {\n          subscription(arg);\n        });\n        return;\n      default:\n        throw new Error(`unrecognized action ${action}`);\n    }\n  };\n}\nfunction statefulStream(initial) {\n  let value = initial;\n  const innerSubject = stream();\n  return (action, arg) => {\n    switch (action) {\n      case SUBSCRIBE:\n        const subscription = arg;\n        subscription(value);\n        break;\n      case PUBLISH:\n        value = arg;\n        break;\n      case VALUE:\n        return value;\n    }\n    return innerSubject(action, arg);\n  };\n}\nfunction eventHandler(emitter) {\n  let unsub;\n  let currentSubscription;\n  const cleanup = () => unsub && unsub();\n  return function(action, subscription) {\n    switch (action) {\n      case SUBSCRIBE:\n        if (subscription) {\n          if (currentSubscription === subscription) {\n            return;\n          }\n          cleanup();\n          currentSubscription = subscription;\n          unsub = subscribe(emitter, subscription);\n          return unsub;\n        } else {\n          cleanup();\n          return noop;\n        }\n      case RESET:\n        cleanup();\n        currentSubscription = null;\n        return;\n      default:\n        throw new Error(`unrecognized action ${action}`);\n    }\n  };\n}\nfunction streamFromEmitter(emitter) {\n  return tap(stream(), (stream2) => connect(emitter, stream2));\n}\nfunction statefulStreamFromEmitter(emitter, initial) {\n  return tap(statefulStream(initial), (stream2) => connect(emitter, stream2));\n}\nfunction combineOperators(...operators) {\n  return (subscriber) => {\n    return operators.reduceRight(thrush, subscriber);\n  };\n}\nfunction pipe(source, ...operators) {\n  const project = combineOperators(...operators);\n  return (action, subscription) => {\n    switch (action) {\n      case SUBSCRIBE:\n        return subscribe(source, project(subscription));\n      case RESET:\n        reset(source);\n        return;\n    }\n  };\n}\nfunction defaultComparator(previous, next) {\n  return previous === next;\n}\nfunction distinctUntilChanged(comparator = defaultComparator) {\n  let current;\n  return (done) => (next) => {\n    if (!comparator(current, next)) {\n      current = next;\n      done(next);\n    }\n  };\n}\nfunction filter(predicate) {\n  return (done) => (value) => {\n    predicate(value) && done(value);\n  };\n}\nfunction map(project) {\n  return (done) => compose(done, project);\n}\nfunction mapTo(value) {\n  return (done) => () => done(value);\n}\nfunction scan(scanner, initial) {\n  return (done) => (value) => done(initial = scanner(initial, value));\n}\nfunction skip(times) {\n  return (done) => (value) => {\n    times > 0 ? times-- : done(value);\n  };\n}\nfunction throttleTime(interval) {\n  let currentValue;\n  let timeout;\n  return (done) => (value) => {\n    currentValue = value;\n    if (timeout) {\n      return;\n    }\n    timeout = setTimeout(() => {\n      timeout = void 0;\n      done(currentValue);\n    }, interval);\n  };\n}\nfunction debounceTime(interval) {\n  let currentValue;\n  let timeout;\n  return (done) => (value) => {\n    currentValue = value;\n    if (timeout) {\n      clearTimeout(timeout);\n    }\n    timeout = setTimeout(() => {\n      done(currentValue);\n    }, interval);\n  };\n}\nfunction withLatestFrom(...sources) {\n  const values = new Array(sources.length);\n  let called = 0;\n  let pendingCall = null;\n  const allCalled = Math.pow(2, sources.length) - 1;\n  sources.forEach((source, index) => {\n    const bit = Math.pow(2, index);\n    subscribe(source, (value) => {\n      const prevCalled = called;\n      called = called | bit;\n      values[index] = value;\n      if (prevCalled !== allCalled && called === allCalled && pendingCall) {\n        pendingCall();\n        pendingCall = null;\n      }\n    });\n  });\n  return (done) => (value) => {\n    const call2 = () => done([value].concat(values));\n    if (called === allCalled) {\n      call2();\n    } else {\n      pendingCall = call2;\n    }\n  };\n}\nfunction merge(...sources) {\n  return function(action, subscription) {\n    switch (action) {\n      case SUBSCRIBE:\n        return joinProc(...sources.map((source) => subscribe(source, subscription)));\n      case RESET:\n        return;\n      default:\n        throw new Error(`unrecognized action ${action}`);\n    }\n  };\n}\nfunction duc(source, comparator = defaultComparator) {\n  return pipe(source, distinctUntilChanged(comparator));\n}\nfunction combineLatest(...emitters) {\n  const innerSubject = stream();\n  const values = new Array(emitters.length);\n  let called = 0;\n  const allCalled = Math.pow(2, emitters.length) - 1;\n  emitters.forEach((source, index) => {\n    const bit = Math.pow(2, index);\n    subscribe(source, (value) => {\n      values[index] = value;\n      called = called | bit;\n      if (called === allCalled) {\n        publish(innerSubject, values);\n      }\n    });\n  });\n  return function(action, subscription) {\n    switch (action) {\n      case SUBSCRIBE:\n        if (called === allCalled) {\n          subscription(values);\n        }\n        return subscribe(innerSubject, subscription);\n      case RESET:\n        return reset(innerSubject);\n      default:\n        throw new Error(`unrecognized action ${action}`);\n    }\n  };\n}\nfunction system(constructor, dependencies = [], { singleton } = { singleton: true }) {\n  return {\n    id: id(),\n    constructor,\n    dependencies,\n    singleton\n  };\n}\nconst id = () => Symbol();\nfunction init(systemSpec) {\n  const singletons = /* @__PURE__ */ new Map();\n  const _init = ({ id: id2, constructor, dependencies, singleton }) => {\n    if (singleton && singletons.has(id2)) {\n      return singletons.get(id2);\n    }\n    const system2 = constructor(dependencies.map((e) => _init(e)));\n    if (singleton) {\n      singletons.set(id2, system2);\n    }\n    return system2;\n  };\n  return _init(systemSpec);\n}\nfunction omit(keys, obj) {\n  const result = {};\n  const index = {};\n  let idx = 0;\n  const len = keys.length;\n  while (idx < len) {\n    index[keys[idx]] = 1;\n    idx += 1;\n  }\n  for (const prop in obj) {\n    if (!index.hasOwnProperty(prop)) {\n      result[prop] = obj[prop];\n    }\n  }\n  return result;\n}\nconst useIsomorphicLayoutEffect$2 = typeof document !== \"undefined\" ? React.useLayoutEffect : React.useEffect;\nfunction systemToComponent(systemSpec, map2, Root) {\n  const requiredPropNames = Object.keys(map2.required || {});\n  const optionalPropNames = Object.keys(map2.optional || {});\n  const methodNames = Object.keys(map2.methods || {});\n  const eventNames = Object.keys(map2.events || {});\n  const Context = React.createContext({});\n  function applyPropsToSystem(system2, props) {\n    if (system2[\"propsReady\"]) {\n      publish(system2[\"propsReady\"], false);\n    }\n    for (const requiredPropName of requiredPropNames) {\n      const stream2 = system2[map2.required[requiredPropName]];\n      publish(stream2, props[requiredPropName]);\n    }\n    for (const optionalPropName of optionalPropNames) {\n      if (optionalPropName in props) {\n        const stream2 = system2[map2.optional[optionalPropName]];\n        publish(stream2, props[optionalPropName]);\n      }\n    }\n    if (system2[\"propsReady\"]) {\n      publish(system2[\"propsReady\"], true);\n    }\n  }\n  function buildMethods(system2) {\n    return methodNames.reduce((acc, methodName) => {\n      acc[methodName] = (value) => {\n        const stream2 = system2[map2.methods[methodName]];\n        publish(stream2, value);\n      };\n      return acc;\n    }, {});\n  }\n  function buildEventHandlers(system2) {\n    return eventNames.reduce((handlers, eventName) => {\n      handlers[eventName] = eventHandler(system2[map2.events[eventName]]);\n      return handlers;\n    }, {});\n  }\n  const Component = React.forwardRef((propsWithChildren, ref) => {\n    const { children, ...props } = propsWithChildren;\n    const [system2] = React.useState(() => {\n      return tap(init(systemSpec), (system22) => applyPropsToSystem(system22, props));\n    });\n    const [handlers] = React.useState(curry1to0(buildEventHandlers, system2));\n    useIsomorphicLayoutEffect$2(() => {\n      for (const eventName of eventNames) {\n        if (eventName in props) {\n          subscribe(handlers[eventName], props[eventName]);\n        }\n      }\n      return () => {\n        Object.values(handlers).map(reset);\n      };\n    }, [props, handlers, system2]);\n    useIsomorphicLayoutEffect$2(() => {\n      applyPropsToSystem(system2, props);\n    });\n    React.useImperativeHandle(ref, always(buildMethods(system2)));\n    return React.createElement(\n      Context.Provider,\n      { value: system2 },\n      Root ? React.createElement(\n        Root,\n        omit([...requiredPropNames, ...optionalPropNames, ...eventNames], props),\n        children\n      ) : children\n    );\n  });\n  const usePublisher2 = (key) => {\n    return React.useCallback(curry2to1(publish, React.useContext(Context)[key]), [key]);\n  };\n  const useEmitterValue2 = (key) => {\n    const system2 = React.useContext(Context);\n    const source = system2[key];\n    const [value, setValue] = React.useState(curry1to0(getValue, source));\n    useIsomorphicLayoutEffect$2(\n      () => subscribe(source, (next) => {\n        if (next !== value) {\n          setValue(always(next));\n        }\n      }),\n      [source, value]\n    );\n    return value;\n  };\n  const useEmitter2 = (key, callback) => {\n    const context = React.useContext(Context);\n    const source = context[key];\n    useIsomorphicLayoutEffect$2(() => subscribe(source, callback), [callback, source]);\n  };\n  return {\n    Component,\n    usePublisher: usePublisher2,\n    useEmitterValue: useEmitterValue2,\n    useEmitter: useEmitter2\n  };\n}\nconst useIsomorphicLayoutEffect = typeof document !== \"undefined\" ? React.useLayoutEffect : React.useEffect;\nconst useIsomorphicLayoutEffect$1 = useIsomorphicLayoutEffect;\nvar LogLevel = /* @__PURE__ */ ((LogLevel2) => {\n  LogLevel2[LogLevel2[\"DEBUG\"] = 0] = \"DEBUG\";\n  LogLevel2[LogLevel2[\"INFO\"] = 1] = \"INFO\";\n  LogLevel2[LogLevel2[\"WARN\"] = 2] = \"WARN\";\n  LogLevel2[LogLevel2[\"ERROR\"] = 3] = \"ERROR\";\n  return LogLevel2;\n})(LogLevel || {});\nconst CONSOLE_METHOD_MAP = {\n  [0]: \"debug\",\n  [1]: \"log\",\n  [2]: \"warn\",\n  [3]: \"error\"\n};\nconst getGlobalThis = () => typeof globalThis === \"undefined\" ? window : globalThis;\nconst loggerSystem = system(\n  () => {\n    const logLevel = statefulStream(3);\n    const log = statefulStream((label, message, level = 1) => {\n      const currentLevel = getGlobalThis()[\"VIRTUOSO_LOG_LEVEL\"] ?? getValue(logLevel);\n      if (level >= currentLevel) {\n        console[CONSOLE_METHOD_MAP[level]](\n          \"%creact-virtuoso: %c%s %o\",\n          \"color: #0253b3; font-weight: bold\",\n          \"color: initial\",\n          label,\n          message\n        );\n      }\n    });\n    return {\n      log,\n      logLevel\n    };\n  },\n  [],\n  { singleton: true }\n);\nfunction useSizeWithElRef(callback, enabled = true) {\n  const ref = React.useRef(null);\n  let callbackRef = (_el) => {\n  };\n  if (typeof ResizeObserver !== \"undefined\") {\n    const observer = new ResizeObserver((entries) => {\n      const element = entries[0].target;\n      if (element.offsetParent !== null) {\n        callback(element);\n      }\n    });\n    callbackRef = (elRef) => {\n      if (elRef && enabled) {\n        observer.observe(elRef);\n        ref.current = elRef;\n      } else {\n        if (ref.current) {\n          observer.unobserve(ref.current);\n        }\n        ref.current = null;\n      }\n    };\n  }\n  return { ref, callbackRef };\n}\nfunction useSize(callback, enabled = true) {\n  return useSizeWithElRef(callback, enabled).callbackRef;\n}\nfunction useChangedListContentsSizes(callback, itemSize, enabled, scrollContainerStateCallback, log, gap, customScrollParent) {\n  return useSizeWithElRef((el) => {\n    const ranges = getChangedChildSizes(el.children, itemSize, \"offsetHeight\", log);\n    let scrollableElement = el.parentElement;\n    while (!scrollableElement.dataset[\"virtuosoScroller\"]) {\n      scrollableElement = scrollableElement.parentElement;\n    }\n    const windowScrolling = scrollableElement.lastElementChild.dataset[\"viewportType\"] === \"window\";\n    const scrollTop = customScrollParent ? customScrollParent.scrollTop : windowScrolling ? window.pageYOffset || document.documentElement.scrollTop : scrollableElement.scrollTop;\n    const scrollHeight = customScrollParent ? customScrollParent.scrollHeight : windowScrolling ? document.documentElement.scrollHeight : scrollableElement.scrollHeight;\n    const viewportHeight = customScrollParent ? customScrollParent.offsetHeight : windowScrolling ? window.innerHeight : scrollableElement.offsetHeight;\n    scrollContainerStateCallback({\n      scrollTop: Math.max(scrollTop, 0),\n      scrollHeight,\n      viewportHeight\n    });\n    gap == null ? void 0 : gap(resolveGapValue$1(\"row-gap\", getComputedStyle(el).rowGap, log));\n    if (ranges !== null) {\n      callback(ranges);\n    }\n  }, enabled);\n}\nfunction getChangedChildSizes(children, itemSize, field, log) {\n  const length = children.length;\n  if (length === 0) {\n    return null;\n  }\n  const results = [];\n  for (let i = 0; i < length; i++) {\n    const child = children.item(i);\n    if (!child || child.dataset.index === void 0) {\n      continue;\n    }\n    const index = parseInt(child.dataset.index);\n    const knownSize = parseFloat(child.dataset.knownSize);\n    const size = itemSize(child, field);\n    if (size === 0) {\n      log(\"Zero-sized element, this should not happen\", { child }, LogLevel.ERROR);\n    }\n    if (size === knownSize) {\n      continue;\n    }\n    const lastResult = results[results.length - 1];\n    if (results.length === 0 || lastResult.size !== size || lastResult.endIndex !== index - 1) {\n      results.push({ startIndex: index, endIndex: index, size });\n    } else {\n      results[results.length - 1].endIndex++;\n    }\n  }\n  return results;\n}\nfunction resolveGapValue$1(property, value, log) {\n  if (value !== \"normal\" && !(value == null ? void 0 : value.endsWith(\"px\"))) {\n    log(`${property} was not resolved to pixel value correctly`, value, LogLevel.WARN);\n  }\n  if (value === \"normal\") {\n    return 0;\n  }\n  return parseInt(value ?? \"0\", 10);\n}\nfunction correctItemSize(el, dimension) {\n  return Math.round(el.getBoundingClientRect()[dimension]);\n}\nfunction approximatelyEqual(num1, num2) {\n  return Math.abs(num1 - num2) < 1.01;\n}\nfunction useScrollTop(scrollContainerStateCallback, smoothScrollTargetReached, scrollerElement, scrollerRefCallback = noop, customScrollParent) {\n  const scrollerRef = React.useRef(null);\n  const scrollTopTarget = React.useRef(null);\n  const timeoutRef = React.useRef(null);\n  const handler = React.useCallback(\n    (ev) => {\n      const el = ev.target;\n      const windowScroll = el === window || el === document;\n      const scrollTop = windowScroll ? window.pageYOffset || document.documentElement.scrollTop : el.scrollTop;\n      const scrollHeight = windowScroll ? document.documentElement.scrollHeight : el.scrollHeight;\n      const viewportHeight = windowScroll ? window.innerHeight : el.offsetHeight;\n      const call2 = () => {\n        scrollContainerStateCallback({\n          scrollTop: Math.max(scrollTop, 0),\n          scrollHeight,\n          viewportHeight\n        });\n      };\n      if (ev.suppressFlushSync) {\n        call2();\n      } else {\n        ReactDOM.flushSync(call2);\n      }\n      if (scrollTopTarget.current !== null) {\n        if (scrollTop === scrollTopTarget.current || scrollTop <= 0 || scrollTop === scrollHeight - viewportHeight) {\n          scrollTopTarget.current = null;\n          smoothScrollTargetReached(true);\n          if (timeoutRef.current) {\n            clearTimeout(timeoutRef.current);\n            timeoutRef.current = null;\n          }\n        }\n      }\n    },\n    [scrollContainerStateCallback, smoothScrollTargetReached]\n  );\n  React.useEffect(() => {\n    const localRef = customScrollParent ? customScrollParent : scrollerRef.current;\n    scrollerRefCallback(customScrollParent ? customScrollParent : scrollerRef.current);\n    handler({ target: localRef, suppressFlushSync: true });\n    localRef.addEventListener(\"scroll\", handler, { passive: true });\n    return () => {\n      scrollerRefCallback(null);\n      localRef.removeEventListener(\"scroll\", handler);\n    };\n  }, [scrollerRef, handler, scrollerElement, scrollerRefCallback, customScrollParent]);\n  function scrollToCallback(location) {\n    const scrollerElement2 = scrollerRef.current;\n    if (!scrollerElement2 || \"offsetHeight\" in scrollerElement2 && scrollerElement2.offsetHeight === 0) {\n      return;\n    }\n    const isSmooth = location.behavior === \"smooth\";\n    let offsetHeight;\n    let scrollHeight;\n    let scrollTop;\n    if (scrollerElement2 === window) {\n      scrollHeight = Math.max(correctItemSize(document.documentElement, \"height\"), document.documentElement.scrollHeight);\n      offsetHeight = window.innerHeight;\n      scrollTop = document.documentElement.scrollTop;\n    } else {\n      scrollHeight = scrollerElement2.scrollHeight;\n      offsetHeight = correctItemSize(scrollerElement2, \"height\");\n      scrollTop = scrollerElement2.scrollTop;\n    }\n    const maxScrollTop = scrollHeight - offsetHeight;\n    location.top = Math.ceil(Math.max(Math.min(maxScrollTop, location.top), 0));\n    if (approximatelyEqual(offsetHeight, scrollHeight) || location.top === scrollTop) {\n      scrollContainerStateCallback({ scrollTop, scrollHeight, viewportHeight: offsetHeight });\n      if (isSmooth) {\n        smoothScrollTargetReached(true);\n      }\n      return;\n    }\n    if (isSmooth) {\n      scrollTopTarget.current = location.top;\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n      }\n      timeoutRef.current = setTimeout(() => {\n        timeoutRef.current = null;\n        scrollTopTarget.current = null;\n        smoothScrollTargetReached(true);\n      }, 1e3);\n    } else {\n      scrollTopTarget.current = null;\n    }\n    scrollerElement2.scrollTo(location);\n  }\n  function scrollByCallback(location) {\n    scrollerRef.current.scrollBy(location);\n  }\n  return { scrollerRef, scrollByCallback, scrollToCallback };\n}\nconst domIOSystem = system(\n  () => {\n    const scrollContainerState = stream();\n    const scrollTop = stream();\n    const deviation = statefulStream(0);\n    const smoothScrollTargetReached = stream();\n    const statefulScrollTop = statefulStream(0);\n    const viewportHeight = stream();\n    const scrollHeight = stream();\n    const headerHeight = statefulStream(0);\n    const fixedHeaderHeight = statefulStream(0);\n    const fixedFooterHeight = statefulStream(0);\n    const footerHeight = statefulStream(0);\n    const scrollTo = stream();\n    const scrollBy = stream();\n    const scrollingInProgress = statefulStream(false);\n    connect(\n      pipe(\n        scrollContainerState,\n        map(({ scrollTop: scrollTop2 }) => scrollTop2)\n      ),\n      scrollTop\n    );\n    connect(\n      pipe(\n        scrollContainerState,\n        map(({ scrollHeight: scrollHeight2 }) => scrollHeight2)\n      ),\n      scrollHeight\n    );\n    connect(scrollTop, statefulScrollTop);\n    return {\n      scrollContainerState,\n      scrollTop,\n      viewportHeight,\n      headerHeight,\n      fixedHeaderHeight,\n      fixedFooterHeight,\n      footerHeight,\n      scrollHeight,\n      smoothScrollTargetReached,\n      scrollTo,\n      scrollBy,\n      statefulScrollTop,\n      deviation,\n      scrollingInProgress\n    };\n  },\n  [],\n  { singleton: true }\n);\nconst NIL_NODE = { lvl: 0 };\nfunction newAANode(k, v, lvl, l = NIL_NODE, r = NIL_NODE) {\n  return { k, v, lvl, l, r };\n}\nfunction empty(node) {\n  return node === NIL_NODE;\n}\nfunction newTree() {\n  return NIL_NODE;\n}\nfunction remove(node, key) {\n  if (empty(node))\n    return NIL_NODE;\n  const { k, l, r } = node;\n  if (key === k) {\n    if (empty(l)) {\n      return r;\n    } else if (empty(r)) {\n      return l;\n    } else {\n      const [lastKey, lastValue] = last(l);\n      return adjust(clone(node, { k: lastKey, v: lastValue, l: deleteLast(l) }));\n    }\n  } else if (key < k) {\n    return adjust(clone(node, { l: remove(l, key) }));\n  } else {\n    return adjust(clone(node, { r: remove(r, key) }));\n  }\n}\nfunction findMaxKeyValue(node, value, field = \"k\") {\n  if (empty(node)) {\n    return [-Infinity, void 0];\n  }\n  if (node[field] === value) {\n    return [node.k, node.v];\n  }\n  if (node[field] < value) {\n    const r = findMaxKeyValue(node.r, value, field);\n    if (r[0] === -Infinity) {\n      return [node.k, node.v];\n    } else {\n      return r;\n    }\n  }\n  return findMaxKeyValue(node.l, value, field);\n}\nfunction insert(node, k, v) {\n  if (empty(node)) {\n    return newAANode(k, v, 1);\n  }\n  if (k === node.k) {\n    return clone(node, { k, v });\n  } else if (k < node.k) {\n    return rebalance(clone(node, { l: insert(node.l, k, v) }));\n  } else {\n    return rebalance(clone(node, { r: insert(node.r, k, v) }));\n  }\n}\nfunction walkWithin(node, start, end) {\n  if (empty(node)) {\n    return [];\n  }\n  const { k, v, l, r } = node;\n  let result = [];\n  if (k > start) {\n    result = result.concat(walkWithin(l, start, end));\n  }\n  if (k >= start && k <= end) {\n    result.push({ k, v });\n  }\n  if (k <= end) {\n    result = result.concat(walkWithin(r, start, end));\n  }\n  return result;\n}\nfunction walk(node) {\n  if (empty(node)) {\n    return [];\n  }\n  return [...walk(node.l), { k: node.k, v: node.v }, ...walk(node.r)];\n}\nfunction last(node) {\n  return empty(node.r) ? [node.k, node.v] : last(node.r);\n}\nfunction deleteLast(node) {\n  return empty(node.r) ? node.l : adjust(clone(node, { r: deleteLast(node.r) }));\n}\nfunction clone(node, args) {\n  return newAANode(\n    args.k !== void 0 ? args.k : node.k,\n    args.v !== void 0 ? args.v : node.v,\n    args.lvl !== void 0 ? args.lvl : node.lvl,\n    args.l !== void 0 ? args.l : node.l,\n    args.r !== void 0 ? args.r : node.r\n  );\n}\nfunction isSingle(node) {\n  return empty(node) || node.lvl > node.r.lvl;\n}\nfunction rebalance(node) {\n  return split(skew(node));\n}\nfunction adjust(node) {\n  const { l, r, lvl } = node;\n  if (r.lvl >= lvl - 1 && l.lvl >= lvl - 1) {\n    return node;\n  } else if (lvl > r.lvl + 1) {\n    if (isSingle(l)) {\n      return skew(clone(node, { lvl: lvl - 1 }));\n    } else {\n      if (!empty(l) && !empty(l.r)) {\n        return clone(l.r, {\n          l: clone(l, { r: l.r.l }),\n          r: clone(node, {\n            l: l.r.r,\n            lvl: lvl - 1\n          }),\n          lvl\n        });\n      } else {\n        throw new Error(\"Unexpected empty nodes\");\n      }\n    }\n  } else {\n    if (isSingle(node)) {\n      return split(clone(node, { lvl: lvl - 1 }));\n    } else {\n      if (!empty(r) && !empty(r.l)) {\n        const rl = r.l;\n        const rlvl = isSingle(rl) ? r.lvl - 1 : r.lvl;\n        return clone(rl, {\n          l: clone(node, {\n            r: rl.l,\n            lvl: lvl - 1\n          }),\n          r: split(clone(r, { l: rl.r, lvl: rlvl })),\n          lvl: rl.lvl + 1\n        });\n      } else {\n        throw new Error(\"Unexpected empty nodes\");\n      }\n    }\n  }\n}\nfunction rangesWithin(node, startIndex, endIndex) {\n  if (empty(node)) {\n    return [];\n  }\n  const adjustedStart = findMaxKeyValue(node, startIndex)[0];\n  return toRanges(walkWithin(node, adjustedStart, endIndex));\n}\nfunction arrayToRanges(items, parser) {\n  const length = items.length;\n  if (length === 0) {\n    return [];\n  }\n  let { index: start, value } = parser(items[0]);\n  const result = [];\n  for (let i = 1; i < length; i++) {\n    const { index: nextIndex, value: nextValue } = parser(items[i]);\n    result.push({ start, end: nextIndex - 1, value });\n    start = nextIndex;\n    value = nextValue;\n  }\n  result.push({ start, end: Infinity, value });\n  return result;\n}\nfunction toRanges(nodes) {\n  return arrayToRanges(nodes, ({ k: index, v: value }) => ({ index, value }));\n}\nfunction split(node) {\n  const { r, lvl } = node;\n  return !empty(r) && !empty(r.r) && r.lvl === lvl && r.r.lvl === lvl ? clone(r, { l: clone(node, { r: r.l }), lvl: lvl + 1 }) : node;\n}\nfunction skew(node) {\n  const { l } = node;\n  return !empty(l) && l.lvl === node.lvl ? clone(l, { r: clone(node, { l: l.r }) }) : node;\n}\nfunction findIndexOfClosestSmallerOrEqual(items, value, comparator, start = 0) {\n  let end = items.length - 1;\n  while (start <= end) {\n    const index = Math.floor((start + end) / 2);\n    const item = items[index];\n    const match = comparator(item, value);\n    if (match === 0) {\n      return index;\n    }\n    if (match === -1) {\n      if (end - start < 2) {\n        return index - 1;\n      }\n      end = index - 1;\n    } else {\n      if (end === start) {\n        return index;\n      }\n      start = index + 1;\n    }\n  }\n  throw new Error(`Failed binary finding record in array - ${items.join(\",\")}, searched for ${value}`);\n}\nfunction findClosestSmallerOrEqual(items, value, comparator) {\n  return items[findIndexOfClosestSmallerOrEqual(items, value, comparator)];\n}\nfunction findRange(items, startValue, endValue, comparator) {\n  const startIndex = findIndexOfClosestSmallerOrEqual(items, startValue, comparator);\n  const endIndex = findIndexOfClosestSmallerOrEqual(items, endValue, comparator, startIndex);\n  return items.slice(startIndex, endIndex + 1);\n}\nconst recalcSystem = system(\n  () => {\n    const recalcInProgress = statefulStream(false);\n    return { recalcInProgress };\n  },\n  [],\n  { singleton: true }\n);\nfunction rangeIncludes(refRange) {\n  const { size, startIndex, endIndex } = refRange;\n  return (range) => {\n    return range.start === startIndex && (range.end === endIndex || range.end === Infinity) && range.value === size;\n  };\n}\nfunction insertRanges(sizeTree, ranges) {\n  let syncStart = empty(sizeTree) ? 0 : Infinity;\n  for (const range of ranges) {\n    const { size, startIndex, endIndex } = range;\n    syncStart = Math.min(syncStart, startIndex);\n    if (empty(sizeTree)) {\n      sizeTree = insert(sizeTree, 0, size);\n      continue;\n    }\n    const overlappingRanges = rangesWithin(sizeTree, startIndex - 1, endIndex + 1);\n    if (overlappingRanges.some(rangeIncludes(range))) {\n      continue;\n    }\n    let firstPassDone = false;\n    let shouldInsert = false;\n    for (const { start: rangeStart, end: rangeEnd, value: rangeValue } of overlappingRanges) {\n      if (!firstPassDone) {\n        shouldInsert = rangeValue !== size;\n        firstPassDone = true;\n      } else {\n        if (endIndex >= rangeStart || size === rangeValue) {\n          sizeTree = remove(sizeTree, rangeStart);\n        }\n      }\n      if (rangeEnd > endIndex && endIndex >= rangeStart) {\n        if (rangeValue !== size) {\n          sizeTree = insert(sizeTree, endIndex + 1, rangeValue);\n        }\n      }\n    }\n    if (shouldInsert) {\n      sizeTree = insert(sizeTree, startIndex, size);\n    }\n  }\n  return [sizeTree, syncStart];\n}\nfunction initialSizeState() {\n  return {\n    offsetTree: [],\n    sizeTree: newTree(),\n    groupOffsetTree: newTree(),\n    lastIndex: 0,\n    lastOffset: 0,\n    lastSize: 0,\n    groupIndices: []\n  };\n}\nfunction indexComparator({ index: itemIndex }, index) {\n  return index === itemIndex ? 0 : index < itemIndex ? -1 : 1;\n}\nfunction offsetComparator({ offset: itemOffset }, offset) {\n  return offset === itemOffset ? 0 : offset < itemOffset ? -1 : 1;\n}\nfunction offsetPointParser(point) {\n  return { index: point.index, value: point };\n}\nfunction rangesWithinOffsets(tree, startOffset, endOffset, minStartIndex = 0) {\n  if (minStartIndex > 0) {\n    startOffset = Math.max(startOffset, findClosestSmallerOrEqual(tree, minStartIndex, indexComparator).offset);\n  }\n  return arrayToRanges(findRange(tree, startOffset, endOffset, offsetComparator), offsetPointParser);\n}\nfunction createOffsetTree(prevOffsetTree, syncStart, sizeTree, gap) {\n  let offsetTree = prevOffsetTree;\n  let prevIndex = 0;\n  let prevSize = 0;\n  let prevOffset = 0;\n  let startIndex = 0;\n  if (syncStart !== 0) {\n    startIndex = findIndexOfClosestSmallerOrEqual(offsetTree, syncStart - 1, indexComparator);\n    const offsetInfo = offsetTree[startIndex];\n    prevOffset = offsetInfo.offset;\n    const kv = findMaxKeyValue(sizeTree, syncStart - 1);\n    prevIndex = kv[0];\n    prevSize = kv[1];\n    if (offsetTree.length && offsetTree[startIndex].size === findMaxKeyValue(sizeTree, syncStart)[1]) {\n      startIndex -= 1;\n    }\n    offsetTree = offsetTree.slice(0, startIndex + 1);\n  } else {\n    offsetTree = [];\n  }\n  for (const { start: startIndex2, value } of rangesWithin(sizeTree, syncStart, Infinity)) {\n    const indexOffset = startIndex2 - prevIndex;\n    const aOffset = indexOffset * prevSize + prevOffset + indexOffset * gap;\n    offsetTree.push({\n      offset: aOffset,\n      size: value,\n      index: startIndex2\n    });\n    prevIndex = startIndex2;\n    prevOffset = aOffset;\n    prevSize = value;\n  }\n  return {\n    offsetTree,\n    lastIndex: prevIndex,\n    lastOffset: prevOffset,\n    lastSize: prevSize\n  };\n}\nfunction sizeStateReducer(state, [ranges, groupIndices, log, gap]) {\n  if (ranges.length > 0) {\n    log(\"received item sizes\", ranges, LogLevel.DEBUG);\n  }\n  const sizeTree = state.sizeTree;\n  let newSizeTree = sizeTree;\n  let syncStart = 0;\n  if (groupIndices.length > 0 && empty(sizeTree) && ranges.length === 2) {\n    const groupSize = ranges[0].size;\n    const itemSize = ranges[1].size;\n    newSizeTree = groupIndices.reduce((tree, groupIndex) => {\n      return insert(insert(tree, groupIndex, groupSize), groupIndex + 1, itemSize);\n    }, newSizeTree);\n  } else {\n    [newSizeTree, syncStart] = insertRanges(newSizeTree, ranges);\n  }\n  if (newSizeTree === sizeTree) {\n    return state;\n  }\n  const { offsetTree: newOffsetTree, lastIndex, lastSize, lastOffset } = createOffsetTree(state.offsetTree, syncStart, newSizeTree, gap);\n  return {\n    sizeTree: newSizeTree,\n    offsetTree: newOffsetTree,\n    lastIndex,\n    lastOffset,\n    lastSize,\n    groupOffsetTree: groupIndices.reduce((tree, index) => {\n      return insert(tree, index, offsetOf(index, newOffsetTree, gap));\n    }, newTree()),\n    groupIndices\n  };\n}\nfunction offsetOf(index, tree, gap) {\n  if (tree.length === 0) {\n    return 0;\n  }\n  const { offset, index: startIndex, size } = findClosestSmallerOrEqual(tree, index, indexComparator);\n  const itemCount = index - startIndex;\n  const top = size * itemCount + (itemCount - 1) * gap + offset;\n  return top > 0 ? top + gap : top;\n}\nfunction isGroupLocation(location) {\n  return typeof location.groupIndex !== \"undefined\";\n}\nfunction originalIndexFromLocation(location, sizes, lastIndex) {\n  if (isGroupLocation(location)) {\n    return sizes.groupIndices[location.groupIndex] + 1;\n  } else {\n    const numericIndex = location.index === \"LAST\" ? lastIndex : location.index;\n    let result = originalIndexFromItemIndex(numericIndex, sizes);\n    result = Math.max(0, result, Math.min(lastIndex, result));\n    return result;\n  }\n}\nfunction originalIndexFromItemIndex(itemIndex, sizes) {\n  if (!hasGroups(sizes)) {\n    return itemIndex;\n  }\n  let groupOffset = 0;\n  while (sizes.groupIndices[groupOffset] <= itemIndex + groupOffset) {\n    groupOffset++;\n  }\n  return itemIndex + groupOffset;\n}\nfunction hasGroups(sizes) {\n  return !empty(sizes.groupOffsetTree);\n}\nconst SIZE_MAP = {\n  offsetHeight: \"height\",\n  offsetWidth: \"width\"\n};\nconst sizeSystem = system(\n  ([{ log }, { recalcInProgress }]) => {\n    const sizeRanges = stream();\n    const totalCount = stream();\n    const statefulTotalCount = statefulStreamFromEmitter(totalCount, 0);\n    const unshiftWith = stream();\n    const shiftWith = stream();\n    const firstItemIndex = statefulStream(0);\n    const groupIndices = statefulStream([]);\n    const fixedItemSize = statefulStream(void 0);\n    const defaultItemSize = statefulStream(void 0);\n    const itemSize = statefulStream((el, field) => correctItemSize(el, SIZE_MAP[field]));\n    const data = statefulStream(void 0);\n    const gap = statefulStream(0);\n    const initial = initialSizeState();\n    const sizes = statefulStreamFromEmitter(\n      pipe(sizeRanges, withLatestFrom(groupIndices, log, gap), scan(sizeStateReducer, initial), distinctUntilChanged()),\n      initial\n    );\n    connect(\n      pipe(\n        groupIndices,\n        filter((indexes) => indexes.length > 0),\n        withLatestFrom(sizes, gap),\n        map(([groupIndices2, sizes2, gap2]) => {\n          const groupOffsetTree = groupIndices2.reduce((tree, index, idx) => {\n            return insert(tree, index, offsetOf(index, sizes2.offsetTree, gap2) || idx);\n          }, newTree());\n          return {\n            ...sizes2,\n            groupIndices: groupIndices2,\n            groupOffsetTree\n          };\n        })\n      ),\n      sizes\n    );\n    connect(\n      pipe(\n        totalCount,\n        withLatestFrom(sizes),\n        filter(([totalCount2, { lastIndex }]) => {\n          return totalCount2 < lastIndex;\n        }),\n        map(([totalCount2, { lastIndex, lastSize }]) => {\n          return [\n            {\n              startIndex: totalCount2,\n              endIndex: lastIndex,\n              size: lastSize\n            }\n          ];\n        })\n      ),\n      sizeRanges\n    );\n    connect(fixedItemSize, defaultItemSize);\n    const trackItemSizes = statefulStreamFromEmitter(\n      pipe(\n        fixedItemSize,\n        map((size) => size === void 0)\n      ),\n      true\n    );\n    connect(\n      pipe(\n        defaultItemSize,\n        filter((value) => {\n          return value !== void 0 && empty(getValue(sizes).sizeTree);\n        }),\n        map((size) => [{ startIndex: 0, endIndex: 0, size }])\n      ),\n      sizeRanges\n    );\n    const listRefresh = streamFromEmitter(\n      pipe(\n        sizeRanges,\n        withLatestFrom(sizes),\n        scan(\n          ({ sizes: oldSizes }, [_, newSizes]) => {\n            return {\n              changed: newSizes !== oldSizes,\n              sizes: newSizes\n            };\n          },\n          { changed: false, sizes: initial }\n        ),\n        map((value) => value.changed)\n      )\n    );\n    subscribe(\n      pipe(\n        firstItemIndex,\n        scan(\n          (prev, next) => {\n            return { diff: prev.prev - next, prev: next };\n          },\n          { diff: 0, prev: 0 }\n        ),\n        map((val) => val.diff)\n      ),\n      (offset) => {\n        if (offset > 0) {\n          publish(recalcInProgress, true);\n          publish(unshiftWith, offset);\n        } else if (offset < 0) {\n          publish(shiftWith, offset);\n        }\n      }\n    );\n    subscribe(pipe(firstItemIndex, withLatestFrom(log)), ([index, log2]) => {\n      if (index < 0) {\n        log2(\n          \"`firstItemIndex` prop should not be set to less than zero. If you don't know the total count, just use a very high value\",\n          { firstItemIndex },\n          LogLevel.ERROR\n        );\n      }\n    });\n    const beforeUnshiftWith = streamFromEmitter(unshiftWith);\n    connect(\n      pipe(\n        unshiftWith,\n        withLatestFrom(sizes),\n        map(([unshiftWith2, sizes2]) => {\n          if (sizes2.groupIndices.length > 0) {\n            throw new Error(\"Virtuoso: prepending items does not work with groups\");\n          }\n          return walk(sizes2.sizeTree).reduce(\n            (acc, { k: index, v: size }) => {\n              return {\n                ranges: [...acc.ranges, { startIndex: acc.prevIndex, endIndex: index + unshiftWith2 - 1, size: acc.prevSize }],\n                prevIndex: index + unshiftWith2,\n                prevSize: size\n              };\n            },\n            {\n              ranges: [],\n              prevIndex: 0,\n              prevSize: sizes2.lastSize\n            }\n          ).ranges;\n        })\n      ),\n      sizeRanges\n    );\n    const shiftWithOffset = streamFromEmitter(\n      pipe(\n        shiftWith,\n        withLatestFrom(sizes, gap),\n        map(([shiftWith2, { offsetTree }, gap2]) => {\n          const newFirstItemIndex = -shiftWith2;\n          return offsetOf(newFirstItemIndex, offsetTree, gap2);\n        })\n      )\n    );\n    connect(\n      pipe(\n        shiftWith,\n        withLatestFrom(sizes, gap),\n        map(([shiftWith2, sizes2, gap2]) => {\n          if (sizes2.groupIndices.length > 0) {\n            throw new Error(\"Virtuoso: shifting items does not work with groups\");\n          }\n          const newSizeTree = walk(sizes2.sizeTree).reduce((acc, { k, v }) => {\n            return insert(acc, Math.max(0, k + shiftWith2), v);\n          }, newTree());\n          return {\n            ...sizes2,\n            sizeTree: newSizeTree,\n            ...createOffsetTree(sizes2.offsetTree, 0, newSizeTree, gap2)\n          };\n        })\n      ),\n      sizes\n    );\n    return {\n      data,\n      totalCount,\n      sizeRanges,\n      groupIndices,\n      defaultItemSize,\n      fixedItemSize,\n      unshiftWith,\n      shiftWith,\n      shiftWithOffset,\n      beforeUnshiftWith,\n      firstItemIndex,\n      gap,\n      sizes,\n      listRefresh,\n      statefulTotalCount,\n      trackItemSizes,\n      itemSize\n    };\n  },\n  tup(loggerSystem, recalcSystem),\n  { singleton: true }\n);\nconst SUPPORTS_SCROLL_TO_OPTIONS = typeof document !== \"undefined\" && \"scrollBehavior\" in document.documentElement.style;\nfunction normalizeIndexLocation(location) {\n  const result = typeof location === \"number\" ? { index: location } : location;\n  if (!result.align) {\n    result.align = \"start\";\n  }\n  if (!result.behavior || !SUPPORTS_SCROLL_TO_OPTIONS) {\n    result.behavior = \"auto\";\n  }\n  if (!result.offset) {\n    result.offset = 0;\n  }\n  return result;\n}\nconst scrollToIndexSystem = system(\n  ([\n    { sizes, totalCount, listRefresh, gap },\n    {\n      scrollingInProgress,\n      viewportHeight,\n      scrollTo,\n      smoothScrollTargetReached,\n      headerHeight,\n      footerHeight,\n      fixedHeaderHeight,\n      fixedFooterHeight\n    },\n    { log }\n  ]) => {\n    const scrollToIndex = stream();\n    const topListHeight = statefulStream(0);\n    let unsubscribeNextListRefresh = null;\n    let cleartTimeoutRef = null;\n    let unsubscribeListRefresh = null;\n    function cleanup() {\n      if (unsubscribeNextListRefresh) {\n        unsubscribeNextListRefresh();\n        unsubscribeNextListRefresh = null;\n      }\n      if (unsubscribeListRefresh) {\n        unsubscribeListRefresh();\n        unsubscribeListRefresh = null;\n      }\n      if (cleartTimeoutRef) {\n        clearTimeout(cleartTimeoutRef);\n        cleartTimeoutRef = null;\n      }\n      publish(scrollingInProgress, false);\n    }\n    connect(\n      pipe(\n        scrollToIndex,\n        withLatestFrom(sizes, viewportHeight, totalCount, topListHeight, headerHeight, footerHeight, log),\n        withLatestFrom(gap, fixedHeaderHeight, fixedFooterHeight),\n        map(\n          ([\n            [location, sizes2, viewportHeight2, totalCount2, topListHeight2, headerHeight2, footerHeight2, log2],\n            gap2,\n            fixedHeaderHeight2,\n            fixedFooterHeight2\n          ]) => {\n            const normalLocation = normalizeIndexLocation(location);\n            const { align, behavior, offset } = normalLocation;\n            const lastIndex = totalCount2 - 1;\n            const index = originalIndexFromLocation(normalLocation, sizes2, lastIndex);\n            let top = offsetOf(index, sizes2.offsetTree, gap2) + headerHeight2;\n            if (align === \"end\") {\n              top += fixedHeaderHeight2 + findMaxKeyValue(sizes2.sizeTree, index)[1] - viewportHeight2 + fixedFooterHeight2;\n              if (index === lastIndex) {\n                top += footerHeight2;\n              }\n            } else if (align === \"center\") {\n              top += (fixedHeaderHeight2 + findMaxKeyValue(sizes2.sizeTree, index)[1] - viewportHeight2 + fixedFooterHeight2) / 2;\n            } else {\n              top -= topListHeight2;\n            }\n            if (offset) {\n              top += offset;\n            }\n            const retry = (listChanged) => {\n              cleanup();\n              if (listChanged) {\n                log2(\"retrying to scroll to\", { location }, LogLevel.DEBUG);\n                publish(scrollToIndex, location);\n              } else {\n                log2(\"list did not change, scroll successful\", {}, LogLevel.DEBUG);\n              }\n            };\n            cleanup();\n            if (behavior === \"smooth\") {\n              let listChanged = false;\n              unsubscribeListRefresh = subscribe(listRefresh, (changed) => {\n                listChanged = listChanged || changed;\n              });\n              unsubscribeNextListRefresh = handleNext(smoothScrollTargetReached, () => {\n                retry(listChanged);\n              });\n            } else {\n              unsubscribeNextListRefresh = handleNext(pipe(listRefresh, watchChangesFor(150)), retry);\n            }\n            cleartTimeoutRef = setTimeout(() => {\n              cleanup();\n            }, 1200);\n            publish(scrollingInProgress, true);\n            log2(\"scrolling from index to\", { index, top, behavior }, LogLevel.DEBUG);\n            return { top, behavior };\n          }\n        )\n      ),\n      scrollTo\n    );\n    return {\n      scrollToIndex,\n      topListHeight\n    };\n  },\n  tup(sizeSystem, domIOSystem, loggerSystem),\n  { singleton: true }\n);\nfunction watchChangesFor(limit) {\n  return (done) => {\n    const timeoutRef = setTimeout(() => {\n      done(false);\n    }, limit);\n    return (value) => {\n      if (value) {\n        done(true);\n        clearTimeout(timeoutRef);\n      }\n    };\n  };\n}\nconst UP = \"up\";\nconst DOWN = \"down\";\nconst NONE$1 = \"none\";\nconst INITIAL_BOTTOM_STATE = {\n  atBottom: false,\n  notAtBottomBecause: \"NOT_SHOWING_LAST_ITEM\",\n  state: {\n    offsetBottom: 0,\n    scrollTop: 0,\n    viewportHeight: 0,\n    scrollHeight: 0\n  }\n};\nconst DEFAULT_AT_TOP_THRESHOLD = 0;\nconst stateFlagsSystem = system(([{ scrollContainerState, scrollTop, viewportHeight, headerHeight, footerHeight, scrollBy }]) => {\n  const isAtBottom = statefulStream(false);\n  const isAtTop = statefulStream(true);\n  const atBottomStateChange = stream();\n  const atTopStateChange = stream();\n  const atBottomThreshold = statefulStream(4);\n  const atTopThreshold = statefulStream(DEFAULT_AT_TOP_THRESHOLD);\n  const isScrolling = statefulStreamFromEmitter(\n    pipe(\n      merge(pipe(duc(scrollTop), skip(1), mapTo(true)), pipe(duc(scrollTop), skip(1), mapTo(false), debounceTime(100))),\n      distinctUntilChanged()\n    ),\n    false\n  );\n  const isScrollingBy = statefulStreamFromEmitter(\n    pipe(merge(pipe(scrollBy, mapTo(true)), pipe(scrollBy, mapTo(false), debounceTime(200))), distinctUntilChanged()),\n    false\n  );\n  connect(\n    pipe(\n      combineLatest(duc(scrollTop), duc(atTopThreshold)),\n      map(([top, atTopThreshold2]) => top <= atTopThreshold2),\n      distinctUntilChanged()\n    ),\n    isAtTop\n  );\n  connect(pipe(isAtTop, throttleTime(50)), atTopStateChange);\n  const atBottomState = streamFromEmitter(\n    pipe(\n      combineLatest(scrollContainerState, duc(viewportHeight), duc(headerHeight), duc(footerHeight), duc(atBottomThreshold)),\n      scan((current, [{ scrollTop: scrollTop2, scrollHeight }, viewportHeight2, _headerHeight, _footerHeight, atBottomThreshold2]) => {\n        const isAtBottom2 = scrollTop2 + viewportHeight2 - scrollHeight > -atBottomThreshold2;\n        const state = {\n          viewportHeight: viewportHeight2,\n          scrollTop: scrollTop2,\n          scrollHeight\n        };\n        if (isAtBottom2) {\n          let atBottomBecause;\n          let scrollTopDelta;\n          if (scrollTop2 > current.state.scrollTop) {\n            atBottomBecause = \"SCROLLED_DOWN\";\n            scrollTopDelta = current.state.scrollTop - scrollTop2;\n          } else {\n            atBottomBecause = \"SIZE_DECREASED\";\n            scrollTopDelta = current.state.scrollTop - scrollTop2 || current.scrollTopDelta;\n          }\n          return {\n            atBottom: true,\n            state,\n            atBottomBecause,\n            scrollTopDelta\n          };\n        }\n        let notAtBottomBecause;\n        if (state.scrollHeight > current.state.scrollHeight) {\n          notAtBottomBecause = \"SIZE_INCREASED\";\n        } else if (viewportHeight2 < current.state.viewportHeight) {\n          notAtBottomBecause = \"VIEWPORT_HEIGHT_DECREASING\";\n        } else if (scrollTop2 < current.state.scrollTop) {\n          notAtBottomBecause = \"SCROLLING_UPWARDS\";\n        } else {\n          notAtBottomBecause = \"NOT_FULLY_SCROLLED_TO_LAST_ITEM_BOTTOM\";\n        }\n        return {\n          atBottom: false,\n          notAtBottomBecause,\n          state\n        };\n      }, INITIAL_BOTTOM_STATE),\n      distinctUntilChanged((prev, next) => {\n        return prev && prev.atBottom === next.atBottom;\n      })\n    )\n  );\n  const lastJumpDueToItemResize = statefulStreamFromEmitter(\n    pipe(\n      scrollContainerState,\n      scan(\n        (current, { scrollTop: scrollTop2, scrollHeight, viewportHeight: viewportHeight2 }) => {\n          if (!approximatelyEqual(current.scrollHeight, scrollHeight)) {\n            const atBottom = scrollHeight - (scrollTop2 + viewportHeight2) < 1;\n            if (current.scrollTop !== scrollTop2 && atBottom) {\n              return {\n                scrollHeight,\n                scrollTop: scrollTop2,\n                jump: current.scrollTop - scrollTop2,\n                changed: true\n              };\n            } else {\n              return {\n                scrollHeight,\n                scrollTop: scrollTop2,\n                jump: 0,\n                changed: true\n              };\n            }\n          } else {\n            return {\n              scrollTop: scrollTop2,\n              scrollHeight,\n              jump: 0,\n              changed: false\n            };\n          }\n        },\n        { scrollHeight: 0, jump: 0, scrollTop: 0, changed: false }\n      ),\n      filter((value) => value.changed),\n      map((value) => value.jump)\n    ),\n    0\n  );\n  connect(\n    pipe(\n      atBottomState,\n      map((state) => state.atBottom)\n    ),\n    isAtBottom\n  );\n  connect(pipe(isAtBottom, throttleTime(50)), atBottomStateChange);\n  const scrollDirection = statefulStream(DOWN);\n  connect(\n    pipe(\n      scrollContainerState,\n      map(({ scrollTop: scrollTop2 }) => scrollTop2),\n      distinctUntilChanged(),\n      scan(\n        (acc, scrollTop2) => {\n          if (getValue(isScrollingBy)) {\n            return { direction: acc.direction, prevScrollTop: scrollTop2 };\n          }\n          return { direction: scrollTop2 < acc.prevScrollTop ? UP : DOWN, prevScrollTop: scrollTop2 };\n        },\n        { direction: DOWN, prevScrollTop: 0 }\n      ),\n      map((value) => value.direction)\n    ),\n    scrollDirection\n  );\n  connect(pipe(scrollContainerState, throttleTime(50), mapTo(NONE$1)), scrollDirection);\n  const scrollVelocity = statefulStream(0);\n  connect(\n    pipe(\n      isScrolling,\n      filter((value) => !value),\n      mapTo(0)\n    ),\n    scrollVelocity\n  );\n  connect(\n    pipe(\n      scrollTop,\n      throttleTime(100),\n      withLatestFrom(isScrolling),\n      filter(([_, isScrolling2]) => !!isScrolling2),\n      scan(([_, prev], [next]) => [prev, next], [0, 0]),\n      map(([prev, next]) => next - prev)\n    ),\n    scrollVelocity\n  );\n  return {\n    isScrolling,\n    isAtTop,\n    isAtBottom,\n    atBottomState,\n    atTopStateChange,\n    atBottomStateChange,\n    scrollDirection,\n    atBottomThreshold,\n    atTopThreshold,\n    scrollVelocity,\n    lastJumpDueToItemResize\n  };\n}, tup(domIOSystem));\nconst propsReadySystem = system(\n  ([{ log }]) => {\n    const propsReady = statefulStream(false);\n    const didMount = streamFromEmitter(\n      pipe(\n        propsReady,\n        filter((ready) => ready),\n        distinctUntilChanged()\n      )\n    );\n    subscribe(propsReady, (value) => {\n      value && getValue(log)(\"props updated\", {}, LogLevel.DEBUG);\n    });\n    return { propsReady, didMount };\n  },\n  tup(loggerSystem),\n  { singleton: true }\n);\nfunction getInitialTopMostItemIndexNumber(location, totalCount) {\n  const lastIndex = totalCount - 1;\n  const index = typeof location === \"number\" ? location : location.index === \"LAST\" ? lastIndex : location.index;\n  return index;\n}\nconst initialTopMostItemIndexSystem = system(\n  ([{ sizes, listRefresh, defaultItemSize }, { scrollTop }, { scrollToIndex }, { didMount }]) => {\n    const scrolledToInitialItem = statefulStream(true);\n    const initialTopMostItemIndex = statefulStream(0);\n    connect(\n      pipe(\n        didMount,\n        withLatestFrom(initialTopMostItemIndex),\n        filter(([_, location]) => !!location),\n        mapTo(false)\n      ),\n      scrolledToInitialItem\n    );\n    subscribe(\n      pipe(\n        combineLatest(listRefresh, didMount),\n        withLatestFrom(scrolledToInitialItem, sizes, defaultItemSize),\n        filter(([[, didMount2], scrolledToInitialItem2, { sizeTree }, defaultItemSize2]) => {\n          return didMount2 && (!empty(sizeTree) || defaultItemSize2 !== void 0) && !scrolledToInitialItem2;\n        }),\n        withLatestFrom(initialTopMostItemIndex)\n      ),\n      ([, initialTopMostItemIndex2]) => {\n        setTimeout(() => {\n          handleNext(scrollTop, () => {\n            publish(scrolledToInitialItem, true);\n          });\n          publish(scrollToIndex, initialTopMostItemIndex2);\n        });\n      }\n    );\n    return {\n      scrolledToInitialItem,\n      initialTopMostItemIndex\n    };\n  },\n  tup(sizeSystem, domIOSystem, scrollToIndexSystem, propsReadySystem),\n  { singleton: true }\n);\nfunction normalizeFollowOutput(follow) {\n  if (!follow) {\n    return false;\n  }\n  return follow === \"smooth\" ? \"smooth\" : \"auto\";\n}\nconst behaviorFromFollowOutput = (follow, isAtBottom) => {\n  if (typeof follow === \"function\") {\n    return normalizeFollowOutput(follow(isAtBottom));\n  }\n  return isAtBottom && normalizeFollowOutput(follow);\n};\nconst followOutputSystem = system(\n  ([\n    { totalCount, listRefresh },\n    { isAtBottom, atBottomState },\n    { scrollToIndex },\n    { scrolledToInitialItem },\n    { propsReady, didMount },\n    { log },\n    { scrollingInProgress }\n  ]) => {\n    const followOutput = statefulStream(false);\n    const autoscrollToBottom = stream();\n    let pendingScrollHandle = null;\n    function scrollToBottom(followOutputBehavior) {\n      publish(scrollToIndex, {\n        index: \"LAST\",\n        align: \"end\",\n        behavior: followOutputBehavior\n      });\n    }\n    subscribe(\n      pipe(\n        combineLatest(pipe(duc(totalCount), skip(1)), didMount),\n        withLatestFrom(duc(followOutput), isAtBottom, scrolledToInitialItem, scrollingInProgress),\n        map(([[totalCount2, didMount2], followOutput2, isAtBottom2, scrolledToInitialItem2, scrollingInProgress2]) => {\n          let shouldFollow = didMount2 && scrolledToInitialItem2;\n          let followOutputBehavior = \"auto\";\n          if (shouldFollow) {\n            followOutputBehavior = behaviorFromFollowOutput(followOutput2, isAtBottom2 || scrollingInProgress2);\n            shouldFollow = shouldFollow && !!followOutputBehavior;\n          }\n          return { totalCount: totalCount2, shouldFollow, followOutputBehavior };\n        }),\n        filter(({ shouldFollow }) => shouldFollow)\n      ),\n      ({ totalCount: totalCount2, followOutputBehavior }) => {\n        if (pendingScrollHandle) {\n          pendingScrollHandle();\n          pendingScrollHandle = null;\n        }\n        pendingScrollHandle = handleNext(listRefresh, () => {\n          getValue(log)(\"following output to \", { totalCount: totalCount2 }, LogLevel.DEBUG);\n          scrollToBottom(followOutputBehavior);\n          pendingScrollHandle = null;\n        });\n      }\n    );\n    function trapNextSizeIncrease(followOutput2) {\n      const cancel = handleNext(atBottomState, (state) => {\n        if (followOutput2 && !state.atBottom && state.notAtBottomBecause === \"SIZE_INCREASED\" && !pendingScrollHandle) {\n          getValue(log)(\"scrolling to bottom due to increased size\", {}, LogLevel.DEBUG);\n          scrollToBottom(\"auto\");\n        }\n      });\n      setTimeout(cancel, 100);\n    }\n    subscribe(\n      pipe(\n        combineLatest(duc(followOutput), totalCount, propsReady),\n        filter(([follow, , ready]) => follow && ready),\n        scan(\n          ({ value }, [, next]) => {\n            return { refreshed: value === next, value: next };\n          },\n          { refreshed: false, value: 0 }\n        ),\n        filter(({ refreshed }) => refreshed),\n        withLatestFrom(followOutput, totalCount)\n      ),\n      ([, followOutput2]) => {\n        trapNextSizeIncrease(followOutput2 !== false);\n      }\n    );\n    subscribe(autoscrollToBottom, () => {\n      trapNextSizeIncrease(getValue(followOutput) !== false);\n    });\n    subscribe(combineLatest(duc(followOutput), atBottomState), ([followOutput2, state]) => {\n      if (followOutput2 && !state.atBottom && state.notAtBottomBecause === \"VIEWPORT_HEIGHT_DECREASING\") {\n        scrollToBottom(\"auto\");\n      }\n    });\n    return { followOutput, autoscrollToBottom };\n  },\n  tup(sizeSystem, stateFlagsSystem, scrollToIndexSystem, initialTopMostItemIndexSystem, propsReadySystem, loggerSystem, domIOSystem)\n);\nfunction groupCountsToIndicesAndCount(counts) {\n  return counts.reduce(\n    (acc, groupCount) => {\n      acc.groupIndices.push(acc.totalCount);\n      acc.totalCount += groupCount + 1;\n      return acc;\n    },\n    {\n      totalCount: 0,\n      groupIndices: []\n    }\n  );\n}\nconst groupedListSystem = system(([{ totalCount, groupIndices, sizes }, { scrollTop, headerHeight }]) => {\n  const groupCounts = stream();\n  const topItemsIndexes = stream();\n  const groupIndicesAndCount = streamFromEmitter(pipe(groupCounts, map(groupCountsToIndicesAndCount)));\n  connect(\n    pipe(\n      groupIndicesAndCount,\n      map((value) => value.totalCount)\n    ),\n    totalCount\n  );\n  connect(\n    pipe(\n      groupIndicesAndCount,\n      map((value) => value.groupIndices)\n    ),\n    groupIndices\n  );\n  connect(\n    pipe(\n      combineLatest(scrollTop, sizes, headerHeight),\n      filter(([_, sizes2]) => hasGroups(sizes2)),\n      map(([scrollTop2, state, headerHeight2]) => findMaxKeyValue(state.groupOffsetTree, Math.max(scrollTop2 - headerHeight2, 0), \"v\")[0]),\n      distinctUntilChanged(),\n      map((index) => [index])\n    ),\n    topItemsIndexes\n  );\n  return { groupCounts, topItemsIndexes };\n}, tup(sizeSystem, domIOSystem));\nfunction tupleComparator(prev, current) {\n  return !!(prev && prev[0] === current[0] && prev[1] === current[1]);\n}\nfunction rangeComparator(prev, next) {\n  return !!(prev && prev.startIndex === next.startIndex && prev.endIndex === next.endIndex);\n}\nconst TOP = \"top\";\nconst BOTTOM = \"bottom\";\nconst NONE = \"none\";\nfunction getOverscan(overscan, end, direction) {\n  if (typeof overscan === \"number\") {\n    return direction === UP && end === TOP || direction === DOWN && end === BOTTOM ? overscan : 0;\n  } else {\n    if (direction === UP) {\n      return end === TOP ? overscan.main : overscan.reverse;\n    } else {\n      return end === BOTTOM ? overscan.main : overscan.reverse;\n    }\n  }\n}\nfunction getViewportIncrease(value, end) {\n  return typeof value === \"number\" ? value : value[end] || 0;\n}\nconst sizeRangeSystem = system(\n  ([{ scrollTop, viewportHeight, deviation, headerHeight, fixedHeaderHeight }]) => {\n    const listBoundary = stream();\n    const topListHeight = statefulStream(0);\n    const increaseViewportBy = statefulStream(0);\n    const overscan = statefulStream(0);\n    const visibleRange = statefulStreamFromEmitter(\n      pipe(\n        combineLatest(\n          duc(scrollTop),\n          duc(viewportHeight),\n          duc(headerHeight),\n          duc(listBoundary, tupleComparator),\n          duc(overscan),\n          duc(topListHeight),\n          duc(fixedHeaderHeight),\n          duc(deviation),\n          duc(increaseViewportBy)\n        ),\n        map(\n          ([\n            scrollTop2,\n            viewportHeight2,\n            headerHeight2,\n            [listTop, listBottom],\n            overscan2,\n            topListHeight2,\n            fixedHeaderHeight2,\n            deviation2,\n            increaseViewportBy2\n          ]) => {\n            const top = scrollTop2 - deviation2;\n            const stickyHeaderHeight = topListHeight2 + fixedHeaderHeight2;\n            const headerVisible = Math.max(headerHeight2 - top, 0);\n            let direction = NONE;\n            const topViewportAddition = getViewportIncrease(increaseViewportBy2, TOP);\n            const bottomViewportAddition = getViewportIncrease(increaseViewportBy2, BOTTOM);\n            listTop -= deviation2;\n            listTop += headerHeight2 + fixedHeaderHeight2;\n            listBottom += headerHeight2 + fixedHeaderHeight2;\n            listBottom -= deviation2;\n            if (listTop > scrollTop2 + stickyHeaderHeight - topViewportAddition) {\n              direction = UP;\n            }\n            if (listBottom < scrollTop2 - headerVisible + viewportHeight2 + bottomViewportAddition) {\n              direction = DOWN;\n            }\n            if (direction !== NONE) {\n              return [\n                Math.max(top - headerHeight2 - getOverscan(overscan2, TOP, direction) - topViewportAddition, 0),\n                top - headerVisible - fixedHeaderHeight2 + viewportHeight2 + getOverscan(overscan2, BOTTOM, direction) + bottomViewportAddition\n              ];\n            }\n            return null;\n          }\n        ),\n        filter((value) => value != null),\n        distinctUntilChanged(tupleComparator)\n      ),\n      [0, 0]\n    );\n    return {\n      listBoundary,\n      overscan,\n      topListHeight,\n      increaseViewportBy,\n      visibleRange\n    };\n  },\n  tup(domIOSystem),\n  { singleton: true }\n);\nfunction probeItemSet(index, sizes, data) {\n  if (hasGroups(sizes)) {\n    const itemIndex = originalIndexFromItemIndex(index, sizes);\n    const groupIndex = findMaxKeyValue(sizes.groupOffsetTree, itemIndex)[0];\n    return [\n      { index: groupIndex, size: 0, offset: 0 },\n      { index: itemIndex, size: 0, offset: 0, data: data && data[0] }\n    ];\n  }\n  return [{ index, size: 0, offset: 0, data: data && data[0] }];\n}\nconst EMPTY_LIST_STATE = {\n  items: [],\n  topItems: [],\n  offsetTop: 0,\n  offsetBottom: 0,\n  top: 0,\n  bottom: 0,\n  topListHeight: 0,\n  totalCount: 0,\n  firstItemIndex: 0\n};\nfunction transposeItems(items, sizes, firstItemIndex) {\n  if (items.length === 0) {\n    return [];\n  }\n  if (!hasGroups(sizes)) {\n    return items.map((item) => ({ ...item, index: item.index + firstItemIndex, originalIndex: item.index }));\n  }\n  const startIndex = items[0].index;\n  const endIndex = items[items.length - 1].index;\n  const transposedItems = [];\n  const groupRanges = rangesWithin(sizes.groupOffsetTree, startIndex, endIndex);\n  let currentRange = void 0;\n  let currentGroupIndex = 0;\n  for (const item of items) {\n    if (!currentRange || currentRange.end < item.index) {\n      currentRange = groupRanges.shift();\n      currentGroupIndex = sizes.groupIndices.indexOf(currentRange.start);\n    }\n    let transposedItem;\n    if (item.index === currentRange.start) {\n      transposedItem = {\n        type: \"group\",\n        index: currentGroupIndex\n      };\n    } else {\n      transposedItem = {\n        index: item.index - (currentGroupIndex + 1) + firstItemIndex,\n        groupIndex: currentGroupIndex\n      };\n    }\n    transposedItems.push({\n      ...transposedItem,\n      size: item.size,\n      offset: item.offset,\n      originalIndex: item.index,\n      data: item.data\n    });\n  }\n  return transposedItems;\n}\nfunction buildListState(items, topItems, totalCount, gap, sizes, firstItemIndex) {\n  const { lastSize, lastOffset, lastIndex } = sizes;\n  let offsetTop = 0;\n  let bottom = 0;\n  if (items.length > 0) {\n    offsetTop = items[0].offset;\n    const lastItem = items[items.length - 1];\n    bottom = lastItem.offset + lastItem.size;\n  }\n  const itemCount = totalCount - lastIndex;\n  const total = lastOffset + itemCount * lastSize + (itemCount - 1) * gap;\n  const top = offsetTop;\n  const offsetBottom = total - bottom;\n  return {\n    items: transposeItems(items, sizes, firstItemIndex),\n    topItems: transposeItems(topItems, sizes, firstItemIndex),\n    topListHeight: topItems.reduce((height, item) => item.size + height, 0),\n    offsetTop,\n    offsetBottom,\n    top,\n    bottom,\n    totalCount,\n    firstItemIndex\n  };\n}\nconst listStateSystem = system(\n  ([\n    { sizes, totalCount, data, firstItemIndex, gap },\n    groupedListSystem2,\n    { visibleRange, listBoundary, topListHeight: rangeTopListHeight },\n    { scrolledToInitialItem, initialTopMostItemIndex },\n    { topListHeight },\n    stateFlags,\n    { didMount },\n    { recalcInProgress }\n  ]) => {\n    const topItemsIndexes = statefulStream([]);\n    const itemsRendered = stream();\n    connect(groupedListSystem2.topItemsIndexes, topItemsIndexes);\n    const listState = statefulStreamFromEmitter(\n      pipe(\n        combineLatest(\n          didMount,\n          recalcInProgress,\n          duc(visibleRange, tupleComparator),\n          duc(totalCount),\n          duc(sizes),\n          duc(initialTopMostItemIndex),\n          scrolledToInitialItem,\n          duc(topItemsIndexes),\n          duc(firstItemIndex),\n          duc(gap),\n          data\n        ),\n        filter(([mount, recalcInProgress2, , totalCount2, , , , , , , data2]) => {\n          const dataChangeInProgress = data2 && data2.length !== totalCount2;\n          return mount && !recalcInProgress2 && !dataChangeInProgress;\n        }),\n        map(\n          ([\n            ,\n            ,\n            [startOffset, endOffset],\n            totalCount2,\n            sizes2,\n            initialTopMostItemIndex2,\n            scrolledToInitialItem2,\n            topItemsIndexes2,\n            firstItemIndex2,\n            gap2,\n            data2\n          ]) => {\n            const sizesValue = sizes2;\n            const { sizeTree, offsetTree } = sizesValue;\n            if (totalCount2 === 0 || startOffset === 0 && endOffset === 0) {\n              return { ...EMPTY_LIST_STATE, totalCount: totalCount2 };\n            }\n            if (empty(sizeTree)) {\n              return buildListState(\n                probeItemSet(getInitialTopMostItemIndexNumber(initialTopMostItemIndex2, totalCount2), sizesValue, data2),\n                [],\n                totalCount2,\n                gap2,\n                sizesValue,\n                firstItemIndex2\n              );\n            }\n            const topItems = [];\n            if (topItemsIndexes2.length > 0) {\n              const startIndex = topItemsIndexes2[0];\n              const endIndex = topItemsIndexes2[topItemsIndexes2.length - 1];\n              let offset = 0;\n              for (const range of rangesWithin(sizeTree, startIndex, endIndex)) {\n                const size = range.value;\n                const rangeStartIndex = Math.max(range.start, startIndex);\n                const rangeEndIndex = Math.min(range.end, endIndex);\n                for (let i = rangeStartIndex; i <= rangeEndIndex; i++) {\n                  topItems.push({ index: i, size, offset, data: data2 && data2[i] });\n                  offset += size;\n                }\n              }\n            }\n            if (!scrolledToInitialItem2) {\n              return buildListState([], topItems, totalCount2, gap2, sizesValue, firstItemIndex2);\n            }\n            const minStartIndex = topItemsIndexes2.length > 0 ? topItemsIndexes2[topItemsIndexes2.length - 1] + 1 : 0;\n            const offsetPointRanges = rangesWithinOffsets(offsetTree, startOffset, endOffset, minStartIndex);\n            if (offsetPointRanges.length === 0) {\n              return null;\n            }\n            const maxIndex = totalCount2 - 1;\n            const items = tap([], (result) => {\n              for (const range of offsetPointRanges) {\n                const point = range.value;\n                let offset = point.offset;\n                let rangeStartIndex = range.start;\n                const size = point.size;\n                if (point.offset < startOffset) {\n                  rangeStartIndex += Math.floor((startOffset - point.offset + gap2) / (size + gap2));\n                  const itemCount = rangeStartIndex - range.start;\n                  offset += itemCount * size + itemCount * gap2;\n                }\n                if (rangeStartIndex < minStartIndex) {\n                  offset += (minStartIndex - rangeStartIndex) * size;\n                  rangeStartIndex = minStartIndex;\n                }\n                const endIndex = Math.min(range.end, maxIndex);\n                for (let i = rangeStartIndex; i <= endIndex; i++) {\n                  if (offset >= endOffset) {\n                    break;\n                  }\n                  result.push({ index: i, size, offset, data: data2 && data2[i] });\n                  offset += size + gap2;\n                }\n              }\n            });\n            return buildListState(items, topItems, totalCount2, gap2, sizesValue, firstItemIndex2);\n          }\n        ),\n        filter((value) => value !== null),\n        distinctUntilChanged()\n      ),\n      EMPTY_LIST_STATE\n    );\n    connect(\n      pipe(\n        data,\n        filter((data2) => data2 !== void 0),\n        map((data2) => data2 == null ? void 0 : data2.length)\n      ),\n      totalCount\n    );\n    connect(\n      pipe(\n        listState,\n        map((value) => value.topListHeight)\n      ),\n      topListHeight\n    );\n    connect(topListHeight, rangeTopListHeight);\n    connect(\n      pipe(\n        listState,\n        map((state) => [state.top, state.bottom])\n      ),\n      listBoundary\n    );\n    connect(\n      pipe(\n        listState,\n        map((state) => state.items)\n      ),\n      itemsRendered\n    );\n    const endReached = streamFromEmitter(\n      pipe(\n        listState,\n        filter(({ items }) => items.length > 0),\n        withLatestFrom(totalCount, data),\n        filter(([{ items }, totalCount2]) => items[items.length - 1].originalIndex === totalCount2 - 1),\n        map(([, totalCount2, data2]) => [totalCount2 - 1, data2]),\n        distinctUntilChanged(tupleComparator),\n        map(([count]) => count)\n      )\n    );\n    const startReached = streamFromEmitter(\n      pipe(\n        listState,\n        throttleTime(200),\n        filter(({ items, topItems }) => {\n          return items.length > 0 && items[0].originalIndex === topItems.length;\n        }),\n        map(({ items }) => items[0].index),\n        distinctUntilChanged()\n      )\n    );\n    const rangeChanged = streamFromEmitter(\n      pipe(\n        listState,\n        filter(({ items }) => items.length > 0),\n        map(({ items }) => {\n          let startIndex = 0;\n          let endIndex = items.length - 1;\n          while (items[startIndex].type === \"group\" && startIndex < endIndex) {\n            startIndex++;\n          }\n          while (items[endIndex].type === \"group\" && endIndex > startIndex) {\n            endIndex--;\n          }\n          return {\n            startIndex: items[startIndex].index,\n            endIndex: items[endIndex].index\n          };\n        }),\n        distinctUntilChanged(rangeComparator)\n      )\n    );\n    return { listState, topItemsIndexes, endReached, startReached, rangeChanged, itemsRendered, ...stateFlags };\n  },\n  tup(\n    sizeSystem,\n    groupedListSystem,\n    sizeRangeSystem,\n    initialTopMostItemIndexSystem,\n    scrollToIndexSystem,\n    stateFlagsSystem,\n    propsReadySystem,\n    recalcSystem\n  ),\n  { singleton: true }\n);\nconst initialItemCountSystem = system(\n  ([{ sizes, firstItemIndex, data, gap }, { listState }, { didMount }]) => {\n    const initialItemCount = statefulStream(0);\n    connect(\n      pipe(\n        didMount,\n        withLatestFrom(initialItemCount),\n        filter(([, count]) => count !== 0),\n        withLatestFrom(sizes, firstItemIndex, gap, data),\n        map(([[, count], sizes2, firstItemIndex2, gap2, data2 = []]) => {\n          let includedGroupsCount = 0;\n          if (sizes2.groupIndices.length > 0) {\n            for (const index of sizes2.groupIndices) {\n              if (index - includedGroupsCount >= count) {\n                break;\n              }\n              includedGroupsCount++;\n            }\n          }\n          const adjustedCount = count + includedGroupsCount;\n          const items = Array.from({ length: adjustedCount }).map((_, index) => ({ index, size: 0, offset: 0, data: data2[index] }));\n          return buildListState(items, [], adjustedCount, gap2, sizes2, firstItemIndex2);\n        })\n      ),\n      listState\n    );\n    return { initialItemCount };\n  },\n  tup(sizeSystem, listStateSystem, propsReadySystem),\n  { singleton: true }\n);\nconst scrollSeekSystem = system(\n  ([{ scrollVelocity }]) => {\n    const isSeeking = statefulStream(false);\n    const rangeChanged = stream();\n    const scrollSeekConfiguration = statefulStream(false);\n    connect(\n      pipe(\n        scrollVelocity,\n        withLatestFrom(scrollSeekConfiguration, isSeeking, rangeChanged),\n        filter(([_, config]) => !!config),\n        map(([speed, config, isSeeking2, range]) => {\n          const { exit, enter } = config;\n          if (isSeeking2) {\n            if (exit(speed, range)) {\n              return false;\n            }\n          } else {\n            if (enter(speed, range)) {\n              return true;\n            }\n          }\n          return isSeeking2;\n        }),\n        distinctUntilChanged()\n      ),\n      isSeeking\n    );\n    subscribe(\n      pipe(combineLatest(isSeeking, scrollVelocity, rangeChanged), withLatestFrom(scrollSeekConfiguration)),\n      ([[isSeeking2, velocity, range], config]) => isSeeking2 && config && config.change && config.change(velocity, range)\n    );\n    return { isSeeking, scrollSeekConfiguration, scrollVelocity, scrollSeekRangeChanged: rangeChanged };\n  },\n  tup(stateFlagsSystem),\n  { singleton: true }\n);\nconst topItemCountSystem = system(([{ topItemsIndexes }]) => {\n  const topItemCount = statefulStream(0);\n  connect(\n    pipe(\n      topItemCount,\n      filter((length) => length > 0),\n      map((length) => Array.from({ length }).map((_, index) => index))\n    ),\n    topItemsIndexes\n  );\n  return { topItemCount };\n}, tup(listStateSystem));\nconst totalListHeightSystem = system(\n  ([{ footerHeight, headerHeight, fixedHeaderHeight, fixedFooterHeight }, { listState }]) => {\n    const totalListHeightChanged = stream();\n    const totalListHeight = statefulStreamFromEmitter(\n      pipe(\n        combineLatest(footerHeight, fixedFooterHeight, headerHeight, fixedHeaderHeight, listState),\n        map(([footerHeight2, fixedFooterHeight2, headerHeight2, fixedHeaderHeight2, listState2]) => {\n          return footerHeight2 + fixedFooterHeight2 + headerHeight2 + fixedHeaderHeight2 + listState2.offsetBottom + listState2.bottom;\n        })\n      ),\n      0\n    );\n    connect(duc(totalListHeight), totalListHeightChanged);\n    return { totalListHeight, totalListHeightChanged };\n  },\n  tup(domIOSystem, listStateSystem),\n  { singleton: true }\n);\nfunction simpleMemoize(func) {\n  let called = false;\n  let result;\n  return () => {\n    if (!called) {\n      called = true;\n      result = func();\n    }\n    return result;\n  };\n}\nconst isMobileSafari = simpleMemoize(() => {\n  return /iP(ad|od|hone)/i.test(navigator.userAgent) && /WebKit/i.test(navigator.userAgent);\n});\nconst upwardScrollFixSystem = system(\n  ([\n    { scrollBy, scrollTop, deviation, scrollingInProgress },\n    { isScrolling, isAtBottom, scrollDirection, lastJumpDueToItemResize },\n    { listState },\n    { beforeUnshiftWith, shiftWithOffset, sizes, gap },\n    { log },\n    { recalcInProgress }\n  ]) => {\n    const deviationOffset = streamFromEmitter(\n      pipe(\n        listState,\n        withLatestFrom(lastJumpDueToItemResize),\n        scan(\n          ([, prevItems, prevTotalCount, prevTotalHeight], [{ items, totalCount, bottom, offsetBottom }, lastJumpDueToItemResize2]) => {\n            const totalHeight = bottom + offsetBottom;\n            let newDev = 0;\n            if (prevTotalCount === totalCount) {\n              if (prevItems.length > 0 && items.length > 0) {\n                const atStart = items[0].originalIndex === 0 && prevItems[0].originalIndex === 0;\n                if (!atStart) {\n                  newDev = totalHeight - prevTotalHeight;\n                  if (newDev !== 0) {\n                    newDev += lastJumpDueToItemResize2;\n                  }\n                }\n              }\n            }\n            return [newDev, items, totalCount, totalHeight];\n          },\n          [0, [], 0, 0]\n        ),\n        filter(([amount]) => amount !== 0),\n        withLatestFrom(scrollTop, scrollDirection, scrollingInProgress, isAtBottom, log),\n        filter(([, scrollTop2, scrollDirection2, scrollingInProgress2]) => {\n          return !scrollingInProgress2 && scrollTop2 !== 0 && scrollDirection2 === UP;\n        }),\n        map(([[amount], , , , , log2]) => {\n          log2(\"Upward scrolling compensation\", { amount }, LogLevel.DEBUG);\n          return amount;\n        })\n      )\n    );\n    function scrollByWith(offset) {\n      if (offset > 0) {\n        publish(scrollBy, { top: -offset, behavior: \"auto\" });\n        publish(deviation, 0);\n      } else {\n        publish(deviation, 0);\n        publish(scrollBy, { top: -offset, behavior: \"auto\" });\n      }\n    }\n    subscribe(pipe(deviationOffset, withLatestFrom(deviation, isScrolling)), ([offset, deviationAmount, isScrolling2]) => {\n      if (isScrolling2 && isMobileSafari()) {\n        publish(deviation, deviationAmount - offset);\n      } else {\n        scrollByWith(-offset);\n      }\n    });\n    subscribe(\n      pipe(\n        combineLatest(statefulStreamFromEmitter(isScrolling, false), deviation, recalcInProgress),\n        filter(([is, deviation2, recalc]) => !is && !recalc && deviation2 !== 0),\n        map(([_, deviation2]) => deviation2),\n        throttleTime(1)\n      ),\n      scrollByWith\n    );\n    connect(\n      pipe(\n        shiftWithOffset,\n        map((offset) => {\n          return { top: -offset };\n        })\n      ),\n      scrollBy\n    );\n    subscribe(\n      pipe(\n        beforeUnshiftWith,\n        withLatestFrom(sizes, gap),\n        map(([offset, { lastSize }, gap2]) => offset * lastSize + offset * gap2)\n      ),\n      (offset) => {\n        publish(deviation, offset);\n        requestAnimationFrame(() => {\n          publish(scrollBy, { top: offset });\n          requestAnimationFrame(() => {\n            publish(deviation, 0);\n            publish(recalcInProgress, false);\n          });\n        });\n      }\n    );\n    return { deviation };\n  },\n  tup(domIOSystem, stateFlagsSystem, listStateSystem, sizeSystem, loggerSystem, recalcSystem)\n);\nconst initialScrollTopSystem = system(\n  ([{ totalListHeight }, { didMount }, { scrollTo }]) => {\n    const initialScrollTop = statefulStream(0);\n    subscribe(\n      pipe(\n        didMount,\n        withLatestFrom(initialScrollTop),\n        filter(([, offset]) => offset !== 0),\n        map(([, offset]) => ({ top: offset }))\n      ),\n      (location) => {\n        handleNext(\n          pipe(\n            totalListHeight,\n            filter((val) => val !== 0)\n          ),\n          () => {\n            setTimeout(() => {\n              publish(scrollTo, location);\n            });\n          }\n        );\n      }\n    );\n    return {\n      initialScrollTop\n    };\n  },\n  tup(totalListHeightSystem, propsReadySystem, domIOSystem),\n  { singleton: true }\n);\nconst alignToBottomSystem = system(\n  ([{ viewportHeight }, { totalListHeight }]) => {\n    const alignToBottom = statefulStream(false);\n    const paddingTopAddition = statefulStreamFromEmitter(\n      pipe(\n        combineLatest(alignToBottom, viewportHeight, totalListHeight),\n        filter(([enabled]) => enabled),\n        map(([, viewportHeight2, totalListHeight2]) => {\n          return Math.max(0, viewportHeight2 - totalListHeight2);\n        }),\n        distinctUntilChanged()\n      ),\n      0\n    );\n    return { alignToBottom, paddingTopAddition };\n  },\n  tup(domIOSystem, totalListHeightSystem),\n  { singleton: true }\n);\nconst windowScrollerSystem = system(([{ scrollTo, scrollContainerState }]) => {\n  const windowScrollContainerState = stream();\n  const windowViewportRect = stream();\n  const windowScrollTo = stream();\n  const useWindowScroll = statefulStream(false);\n  const customScrollParent = statefulStream(void 0);\n  connect(\n    pipe(\n      combineLatest(windowScrollContainerState, windowViewportRect),\n      map(([{ viewportHeight, scrollTop: windowScrollTop, scrollHeight }, { offsetTop }]) => {\n        return {\n          scrollTop: Math.max(0, windowScrollTop - offsetTop),\n          scrollHeight,\n          viewportHeight\n        };\n      })\n    ),\n    scrollContainerState\n  );\n  connect(\n    pipe(\n      scrollTo,\n      withLatestFrom(windowViewportRect),\n      map(([scrollTo2, { offsetTop }]) => {\n        return {\n          ...scrollTo2,\n          top: scrollTo2.top + offsetTop\n        };\n      })\n    ),\n    windowScrollTo\n  );\n  return {\n    useWindowScroll,\n    customScrollParent,\n    windowScrollContainerState,\n    windowViewportRect,\n    windowScrollTo\n  };\n}, tup(domIOSystem));\nconst scrollIntoViewSystem = system(\n  ([\n    { sizes, totalCount, gap },\n    { scrollTop, viewportHeight, headerHeight, fixedHeaderHeight, fixedFooterHeight, scrollingInProgress },\n    { scrollToIndex }\n  ]) => {\n    const scrollIntoView = stream();\n    connect(\n      pipe(\n        scrollIntoView,\n        withLatestFrom(sizes, viewportHeight, totalCount, headerHeight, fixedHeaderHeight, fixedFooterHeight, scrollTop),\n        withLatestFrom(gap),\n        map(([[viewLocation, sizes2, viewportHeight2, totalCount2, headerHeight2, fixedHeaderHeight2, fixedFooterHeight2, scrollTop2], gap2]) => {\n          const { done, behavior, align, ...rest } = viewLocation;\n          let location = null;\n          const actualIndex = originalIndexFromLocation(viewLocation, sizes2, totalCount2 - 1);\n          const itemTop2 = offsetOf(actualIndex, sizes2.offsetTree, gap2) + headerHeight2 + fixedHeaderHeight2;\n          if (itemTop2 < scrollTop2 + fixedHeaderHeight2) {\n            location = { ...rest, behavior, align: align ?? \"start\" };\n          } else {\n            const itemBottom = itemTop2 + findMaxKeyValue(sizes2.sizeTree, actualIndex)[1];\n            if (itemBottom > scrollTop2 + viewportHeight2 - fixedFooterHeight2) {\n              location = { ...rest, behavior, align: align ?? \"end\" };\n            }\n          }\n          if (location) {\n            done && handleNext(\n              pipe(\n                scrollingInProgress,\n                skip(1),\n                filter((value) => value === false)\n              ),\n              done\n            );\n          } else {\n            done && done();\n          }\n          return location;\n        }),\n        filter((value) => value !== null)\n      ),\n      scrollToIndex\n    );\n    return {\n      scrollIntoView\n    };\n  },\n  tup(sizeSystem, domIOSystem, scrollToIndexSystem, listStateSystem, loggerSystem),\n  { singleton: true }\n);\nconst featureGroup1System = system(\n  ([\n    sizeRange,\n    initialItemCount,\n    propsReady,\n    scrollSeek,\n    totalListHeight,\n    initialScrollTopSystem2,\n    alignToBottom,\n    windowScroller,\n    scrollIntoView\n  ]) => {\n    return {\n      ...sizeRange,\n      ...initialItemCount,\n      ...propsReady,\n      ...scrollSeek,\n      ...totalListHeight,\n      ...initialScrollTopSystem2,\n      ...alignToBottom,\n      ...windowScroller,\n      ...scrollIntoView\n    };\n  },\n  tup(\n    sizeRangeSystem,\n    initialItemCountSystem,\n    propsReadySystem,\n    scrollSeekSystem,\n    totalListHeightSystem,\n    initialScrollTopSystem,\n    alignToBottomSystem,\n    windowScrollerSystem,\n    scrollIntoViewSystem\n  )\n);\nconst listSystem = system(\n  ([\n    {\n      totalCount,\n      sizeRanges,\n      fixedItemSize,\n      defaultItemSize,\n      trackItemSizes,\n      itemSize,\n      data,\n      firstItemIndex,\n      groupIndices,\n      statefulTotalCount,\n      gap\n    },\n    { initialTopMostItemIndex, scrolledToInitialItem },\n    domIO,\n    followOutput,\n    { listState, topItemsIndexes, ...flags },\n    { scrollToIndex },\n    _,\n    { topItemCount },\n    { groupCounts },\n    featureGroup1,\n    log\n  ]) => {\n    connect(flags.rangeChanged, featureGroup1.scrollSeekRangeChanged);\n    connect(\n      pipe(\n        featureGroup1.windowViewportRect,\n        map((value) => value.visibleHeight)\n      ),\n      domIO.viewportHeight\n    );\n    return {\n      totalCount,\n      data,\n      firstItemIndex,\n      sizeRanges,\n      initialTopMostItemIndex,\n      scrolledToInitialItem,\n      topItemsIndexes,\n      topItemCount,\n      groupCounts,\n      fixedItemHeight: fixedItemSize,\n      defaultItemHeight: defaultItemSize,\n      gap,\n      ...followOutput,\n      statefulTotalCount,\n      listState,\n      scrollToIndex,\n      trackItemSizes,\n      itemSize,\n      groupIndices,\n      ...flags,\n      ...featureGroup1,\n      ...domIO,\n      ...log\n    };\n  },\n  tup(\n    sizeSystem,\n    initialTopMostItemIndexSystem,\n    domIOSystem,\n    followOutputSystem,\n    listStateSystem,\n    scrollToIndexSystem,\n    upwardScrollFixSystem,\n    topItemCountSystem,\n    groupedListSystem,\n    featureGroup1System,\n    loggerSystem\n  )\n);\nconst WEBKIT_STICKY = \"-webkit-sticky\";\nconst STICKY = \"sticky\";\nconst positionStickyCssValue = simpleMemoize(() => {\n  if (typeof document === \"undefined\") {\n    return STICKY;\n  }\n  const node = document.createElement(\"div\");\n  node.style.position = WEBKIT_STICKY;\n  return node.style.position === WEBKIT_STICKY ? WEBKIT_STICKY : STICKY;\n});\nfunction useWindowViewportRectRef(callback, customScrollParent) {\n  const viewportInfo = React.useRef(null);\n  const calculateInfo = React.useCallback(\n    (element) => {\n      if (element === null || !element.offsetParent) {\n        return;\n      }\n      const rect = element.getBoundingClientRect();\n      const visibleWidth = rect.width;\n      let visibleHeight, offsetTop;\n      if (customScrollParent) {\n        const customScrollParentRect = customScrollParent.getBoundingClientRect();\n        const deltaTop = rect.top - customScrollParentRect.top;\n        visibleHeight = customScrollParentRect.height - Math.max(0, deltaTop);\n        offsetTop = deltaTop + customScrollParent.scrollTop;\n      } else {\n        visibleHeight = window.innerHeight - Math.max(0, rect.top);\n        offsetTop = rect.top + window.pageYOffset;\n      }\n      viewportInfo.current = {\n        offsetTop,\n        visibleHeight,\n        visibleWidth\n      };\n      callback(viewportInfo.current);\n    },\n    [callback, customScrollParent]\n  );\n  const { callbackRef, ref } = useSizeWithElRef(calculateInfo);\n  const scrollAndResizeEventHandler = React.useCallback(() => {\n    calculateInfo(ref.current);\n  }, [calculateInfo, ref]);\n  React.useEffect(() => {\n    if (customScrollParent) {\n      customScrollParent.addEventListener(\"scroll\", scrollAndResizeEventHandler);\n      const observer = new ResizeObserver(scrollAndResizeEventHandler);\n      observer.observe(customScrollParent);\n      return () => {\n        customScrollParent.removeEventListener(\"scroll\", scrollAndResizeEventHandler);\n        observer.unobserve(customScrollParent);\n      };\n    } else {\n      window.addEventListener(\"scroll\", scrollAndResizeEventHandler);\n      window.addEventListener(\"resize\", scrollAndResizeEventHandler);\n      return () => {\n        window.removeEventListener(\"scroll\", scrollAndResizeEventHandler);\n        window.removeEventListener(\"resize\", scrollAndResizeEventHandler);\n      };\n    }\n  }, [scrollAndResizeEventHandler, customScrollParent]);\n  return callbackRef;\n}\nconst VirtuosoMockContext = React.createContext(void 0);\nconst VirtuosoGridMockContext = React.createContext(void 0);\nfunction identity(value) {\n  return value;\n}\nconst listComponentPropsSystem = /* @__PURE__ */ system(() => {\n  const itemContent = statefulStream((index) => `Item ${index}`);\n  const context = statefulStream(null);\n  const groupContent = statefulStream((index) => `Group ${index}`);\n  const components = statefulStream({});\n  const computeItemKey = statefulStream(identity);\n  const headerFooterTag = statefulStream(\"div\");\n  const scrollerRef = statefulStream(noop);\n  const distinctProp = (propName, defaultValue = null) => {\n    return statefulStreamFromEmitter(\n      pipe(\n        components,\n        map((components2) => components2[propName]),\n        distinctUntilChanged()\n      ),\n      defaultValue\n    );\n  };\n  return {\n    context,\n    itemContent,\n    groupContent,\n    components,\n    computeItemKey,\n    headerFooterTag,\n    scrollerRef,\n    FooterComponent: distinctProp(\"Footer\"),\n    HeaderComponent: distinctProp(\"Header\"),\n    TopItemListComponent: distinctProp(\"TopItemList\"),\n    ListComponent: distinctProp(\"List\", \"div\"),\n    ItemComponent: distinctProp(\"Item\", \"div\"),\n    GroupComponent: distinctProp(\"Group\", \"div\"),\n    ScrollerComponent: distinctProp(\"Scroller\", \"div\"),\n    EmptyPlaceholder: distinctProp(\"EmptyPlaceholder\"),\n    ScrollSeekPlaceholder: distinctProp(\"ScrollSeekPlaceholder\")\n  };\n});\nconst combinedSystem$2 = /* @__PURE__ */ system(([listSystem2, propsSystem]) => {\n  return { ...listSystem2, ...propsSystem };\n}, tup(listSystem, listComponentPropsSystem));\nconst DefaultScrollSeekPlaceholder$1 = ({ height }) => /* @__PURE__ */ React.createElement(\"div\", { style: { height } });\nconst GROUP_STYLE = { position: positionStickyCssValue(), zIndex: 1, overflowAnchor: \"none\" };\nconst ITEM_STYLE = { overflowAnchor: \"none\" };\nconst Items$1 = /* @__PURE__ */ React.memo(function VirtuosoItems({ showTopList = false }) {\n  const listState = useEmitterValue$2(\"listState\");\n  const sizeRanges = usePublisher$2(\"sizeRanges\");\n  const useWindowScroll = useEmitterValue$2(\"useWindowScroll\");\n  const customScrollParent = useEmitterValue$2(\"customScrollParent\");\n  const windowScrollContainerStateCallback = usePublisher$2(\"windowScrollContainerState\");\n  const _scrollContainerStateCallback = usePublisher$2(\"scrollContainerState\");\n  const scrollContainerStateCallback = customScrollParent || useWindowScroll ? windowScrollContainerStateCallback : _scrollContainerStateCallback;\n  const itemContent = useEmitterValue$2(\"itemContent\");\n  const context = useEmitterValue$2(\"context\");\n  const groupContent = useEmitterValue$2(\"groupContent\");\n  const trackItemSizes = useEmitterValue$2(\"trackItemSizes\");\n  const itemSize = useEmitterValue$2(\"itemSize\");\n  const log = useEmitterValue$2(\"log\");\n  const listGap = usePublisher$2(\"gap\");\n  const { callbackRef } = useChangedListContentsSizes(\n    sizeRanges,\n    itemSize,\n    trackItemSizes,\n    showTopList ? noop : scrollContainerStateCallback,\n    log,\n    listGap,\n    customScrollParent\n  );\n  const [deviation, setDeviation] = React.useState(0);\n  useEmitter$2(\"deviation\", (value) => {\n    if (deviation !== value) {\n      setDeviation(value);\n    }\n  });\n  const EmptyPlaceholder = useEmitterValue$2(\"EmptyPlaceholder\");\n  const ScrollSeekPlaceholder = useEmitterValue$2(\"ScrollSeekPlaceholder\") || DefaultScrollSeekPlaceholder$1;\n  const ListComponent = useEmitterValue$2(\"ListComponent\");\n  const ItemComponent = useEmitterValue$2(\"ItemComponent\");\n  const GroupComponent = useEmitterValue$2(\"GroupComponent\");\n  const computeItemKey = useEmitterValue$2(\"computeItemKey\");\n  const isSeeking = useEmitterValue$2(\"isSeeking\");\n  const hasGroups2 = useEmitterValue$2(\"groupIndices\").length > 0;\n  const paddingTopAddition = useEmitterValue$2(\"paddingTopAddition\");\n  const containerStyle = showTopList ? {} : {\n    boxSizing: \"border-box\",\n    paddingTop: listState.offsetTop + paddingTopAddition,\n    paddingBottom: listState.offsetBottom,\n    marginTop: deviation\n  };\n  if (!showTopList && listState.totalCount === 0 && EmptyPlaceholder) {\n    return React.createElement(EmptyPlaceholder, contextPropIfNotDomElement(EmptyPlaceholder, context));\n  }\n  return React.createElement(\n    ListComponent,\n    {\n      ...contextPropIfNotDomElement(ListComponent, context),\n      ref: callbackRef,\n      style: containerStyle,\n      \"data-test-id\": showTopList ? \"virtuoso-top-item-list\" : \"virtuoso-item-list\"\n    },\n    (showTopList ? listState.topItems : listState.items).map((item) => {\n      const index = item.originalIndex;\n      const key = computeItemKey(index + listState.firstItemIndex, item.data, context);\n      if (isSeeking) {\n        return React.createElement(ScrollSeekPlaceholder, {\n          ...contextPropIfNotDomElement(ScrollSeekPlaceholder, context),\n          key,\n          index: item.index,\n          height: item.size,\n          type: item.type || \"item\",\n          ...item.type === \"group\" ? {} : { groupIndex: item.groupIndex }\n        });\n      }\n      if (item.type === \"group\") {\n        return React.createElement(\n          GroupComponent,\n          {\n            ...contextPropIfNotDomElement(GroupComponent, context),\n            key,\n            \"data-index\": index,\n            \"data-known-size\": item.size,\n            \"data-item-index\": item.index,\n            style: GROUP_STYLE\n          },\n          groupContent(item.index)\n        );\n      } else {\n        return React.createElement(\n          ItemComponent,\n          {\n            ...contextPropIfNotDomElement(ItemComponent, context),\n            key,\n            \"data-index\": index,\n            \"data-known-size\": item.size,\n            \"data-item-index\": item.index,\n            \"data-item-group-index\": item.groupIndex,\n            item: item.data,\n            style: ITEM_STYLE\n          },\n          hasGroups2 ? itemContent(item.index, item.groupIndex, item.data, context) : itemContent(item.index, item.data, context)\n        );\n      }\n    })\n  );\n});\nconst scrollerStyle = {\n  height: \"100%\",\n  outline: \"none\",\n  overflowY: \"auto\",\n  position: \"relative\",\n  WebkitOverflowScrolling: \"touch\"\n};\nconst viewportStyle = {\n  width: \"100%\",\n  height: \"100%\",\n  position: \"absolute\",\n  top: 0\n};\nconst topItemListStyle = {\n  width: \"100%\",\n  position: positionStickyCssValue(),\n  top: 0,\n  zIndex: 1\n};\nfunction contextPropIfNotDomElement(element, context) {\n  if (typeof element === \"string\") {\n    return void 0;\n  }\n  return { context };\n}\nconst Header$1 = /* @__PURE__ */ React.memo(function VirtuosoHeader() {\n  const Header2 = useEmitterValue$2(\"HeaderComponent\");\n  const headerHeight = usePublisher$2(\"headerHeight\");\n  const headerFooterTag = useEmitterValue$2(\"headerFooterTag\");\n  const ref = useSize((el) => headerHeight(correctItemSize(el, \"height\")));\n  const context = useEmitterValue$2(\"context\");\n  return Header2 ? React.createElement(headerFooterTag, { ref }, React.createElement(Header2, contextPropIfNotDomElement(Header2, context))) : null;\n});\nconst Footer$1 = /* @__PURE__ */ React.memo(function VirtuosoFooter() {\n  const Footer2 = useEmitterValue$2(\"FooterComponent\");\n  const footerHeight = usePublisher$2(\"footerHeight\");\n  const headerFooterTag = useEmitterValue$2(\"headerFooterTag\");\n  const ref = useSize((el) => footerHeight(correctItemSize(el, \"height\")));\n  const context = useEmitterValue$2(\"context\");\n  return Footer2 ? React.createElement(headerFooterTag, { ref }, React.createElement(Footer2, contextPropIfNotDomElement(Footer2, context))) : null;\n});\nfunction buildScroller({ usePublisher: usePublisher2, useEmitter: useEmitter2, useEmitterValue: useEmitterValue2 }) {\n  const Scroller2 = React.memo(function VirtuosoScroller({ style, children, ...props }) {\n    const scrollContainerStateCallback = usePublisher2(\"scrollContainerState\");\n    const ScrollerComponent = useEmitterValue2(\"ScrollerComponent\");\n    const smoothScrollTargetReached = usePublisher2(\"smoothScrollTargetReached\");\n    const scrollerRefCallback = useEmitterValue2(\"scrollerRef\");\n    const context = useEmitterValue2(\"context\");\n    const { scrollerRef, scrollByCallback, scrollToCallback } = useScrollTop(\n      scrollContainerStateCallback,\n      smoothScrollTargetReached,\n      ScrollerComponent,\n      scrollerRefCallback\n    );\n    useEmitter2(\"scrollTo\", scrollToCallback);\n    useEmitter2(\"scrollBy\", scrollByCallback);\n    return React.createElement(\n      ScrollerComponent,\n      {\n        ref: scrollerRef,\n        style: { ...scrollerStyle, ...style },\n        \"data-test-id\": \"virtuoso-scroller\",\n        \"data-virtuoso-scroller\": true,\n        tabIndex: 0,\n        ...props,\n        ...contextPropIfNotDomElement(ScrollerComponent, context)\n      },\n      children\n    );\n  });\n  return Scroller2;\n}\nfunction buildWindowScroller({ usePublisher: usePublisher2, useEmitter: useEmitter2, useEmitterValue: useEmitterValue2 }) {\n  const Scroller2 = React.memo(function VirtuosoWindowScroller({ style, children, ...props }) {\n    const scrollContainerStateCallback = usePublisher2(\"windowScrollContainerState\");\n    const ScrollerComponent = useEmitterValue2(\"ScrollerComponent\");\n    const smoothScrollTargetReached = usePublisher2(\"smoothScrollTargetReached\");\n    const totalListHeight = useEmitterValue2(\"totalListHeight\");\n    const deviation = useEmitterValue2(\"deviation\");\n    const customScrollParent = useEmitterValue2(\"customScrollParent\");\n    const context = useEmitterValue2(\"context\");\n    const { scrollerRef, scrollByCallback, scrollToCallback } = useScrollTop(\n      scrollContainerStateCallback,\n      smoothScrollTargetReached,\n      ScrollerComponent,\n      noop,\n      customScrollParent\n    );\n    useIsomorphicLayoutEffect$1(() => {\n      scrollerRef.current = customScrollParent ? customScrollParent : window;\n      return () => {\n        scrollerRef.current = null;\n      };\n    }, [scrollerRef, customScrollParent]);\n    useEmitter2(\"windowScrollTo\", scrollToCallback);\n    useEmitter2(\"scrollBy\", scrollByCallback);\n    return React.createElement(\n      ScrollerComponent,\n      {\n        style: { position: \"relative\", ...style, ...totalListHeight !== 0 ? { height: totalListHeight + deviation } : {} },\n        \"data-virtuoso-scroller\": true,\n        ...props,\n        ...contextPropIfNotDomElement(ScrollerComponent, context)\n      },\n      children\n    );\n  });\n  return Scroller2;\n}\nconst Viewport$2 = ({ children }) => {\n  const ctx = React.useContext(VirtuosoMockContext);\n  const viewportHeight = usePublisher$2(\"viewportHeight\");\n  const fixedItemHeight = usePublisher$2(\"fixedItemHeight\");\n  const viewportRef = useSize(compose(viewportHeight, (el) => correctItemSize(el, \"height\")));\n  React.useEffect(() => {\n    if (ctx) {\n      viewportHeight(ctx.viewportHeight);\n      fixedItemHeight(ctx.itemHeight);\n    }\n  }, [ctx, viewportHeight, fixedItemHeight]);\n  return /* @__PURE__ */ React.createElement(\"div\", { style: viewportStyle, ref: viewportRef, \"data-viewport-type\": \"element\" }, children);\n};\nconst WindowViewport$2 = ({ children }) => {\n  const ctx = React.useContext(VirtuosoMockContext);\n  const windowViewportRect = usePublisher$2(\"windowViewportRect\");\n  const fixedItemHeight = usePublisher$2(\"fixedItemHeight\");\n  const customScrollParent = useEmitterValue$2(\"customScrollParent\");\n  const viewportRef = useWindowViewportRectRef(windowViewportRect, customScrollParent);\n  React.useEffect(() => {\n    if (ctx) {\n      fixedItemHeight(ctx.itemHeight);\n      windowViewportRect({ offsetTop: 0, visibleHeight: ctx.viewportHeight, visibleWidth: 100 });\n    }\n  }, [ctx, windowViewportRect, fixedItemHeight]);\n  return /* @__PURE__ */ React.createElement(\"div\", { ref: viewportRef, style: viewportStyle, \"data-viewport-type\": \"window\" }, children);\n};\nconst TopItemListContainer = ({ children }) => {\n  const TopItemList = useEmitterValue$2(\"TopItemListComponent\");\n  const headerHeight = useEmitterValue$2(\"headerHeight\");\n  const style = { ...topItemListStyle, marginTop: `${headerHeight}px` };\n  const context = useEmitterValue$2(\"context\");\n  return React.createElement(TopItemList || \"div\", { style, context }, children);\n};\nconst ListRoot = /* @__PURE__ */ React.memo(function VirtuosoRoot(props) {\n  const useWindowScroll = useEmitterValue$2(\"useWindowScroll\");\n  const showTopList = useEmitterValue$2(\"topItemsIndexes\").length > 0;\n  const customScrollParent = useEmitterValue$2(\"customScrollParent\");\n  const TheScroller = customScrollParent || useWindowScroll ? WindowScroller$2 : Scroller$2;\n  const TheViewport = customScrollParent || useWindowScroll ? WindowViewport$2 : Viewport$2;\n  return /* @__PURE__ */ React.createElement(TheScroller, { ...props }, showTopList && /* @__PURE__ */ React.createElement(TopItemListContainer, null, /* @__PURE__ */ React.createElement(Items$1, { showTopList: true })), /* @__PURE__ */ React.createElement(TheViewport, null, /* @__PURE__ */ React.createElement(Header$1, null), /* @__PURE__ */ React.createElement(Items$1, null), /* @__PURE__ */ React.createElement(Footer$1, null)));\n});\nconst {\n  Component: List,\n  usePublisher: usePublisher$2,\n  useEmitterValue: useEmitterValue$2,\n  useEmitter: useEmitter$2\n} = /* @__PURE__ */ systemToComponent(\n  combinedSystem$2,\n  {\n    required: {},\n    optional: {\n      context: \"context\",\n      followOutput: \"followOutput\",\n      firstItemIndex: \"firstItemIndex\",\n      itemContent: \"itemContent\",\n      groupContent: \"groupContent\",\n      overscan: \"overscan\",\n      increaseViewportBy: \"increaseViewportBy\",\n      totalCount: \"totalCount\",\n      topItemCount: \"topItemCount\",\n      initialTopMostItemIndex: \"initialTopMostItemIndex\",\n      components: \"components\",\n      groupCounts: \"groupCounts\",\n      atBottomThreshold: \"atBottomThreshold\",\n      atTopThreshold: \"atTopThreshold\",\n      computeItemKey: \"computeItemKey\",\n      defaultItemHeight: \"defaultItemHeight\",\n      fixedItemHeight: \"fixedItemHeight\",\n      itemSize: \"itemSize\",\n      scrollSeekConfiguration: \"scrollSeekConfiguration\",\n      headerFooterTag: \"headerFooterTag\",\n      data: \"data\",\n      initialItemCount: \"initialItemCount\",\n      initialScrollTop: \"initialScrollTop\",\n      alignToBottom: \"alignToBottom\",\n      useWindowScroll: \"useWindowScroll\",\n      customScrollParent: \"customScrollParent\",\n      scrollerRef: \"scrollerRef\",\n      logLevel: \"logLevel\"\n    },\n    methods: {\n      scrollToIndex: \"scrollToIndex\",\n      scrollIntoView: \"scrollIntoView\",\n      scrollTo: \"scrollTo\",\n      scrollBy: \"scrollBy\",\n      autoscrollToBottom: \"autoscrollToBottom\"\n    },\n    events: {\n      isScrolling: \"isScrolling\",\n      endReached: \"endReached\",\n      startReached: \"startReached\",\n      rangeChanged: \"rangeChanged\",\n      atBottomStateChange: \"atBottomStateChange\",\n      atTopStateChange: \"atTopStateChange\",\n      totalListHeightChanged: \"totalListHeightChanged\",\n      itemsRendered: \"itemsRendered\",\n      groupIndices: \"groupIndices\"\n    }\n  },\n  ListRoot\n);\nconst Scroller$2 = /* @__PURE__ */ buildScroller({ usePublisher: usePublisher$2, useEmitterValue: useEmitterValue$2, useEmitter: useEmitter$2 });\nconst WindowScroller$2 = /* @__PURE__ */ buildWindowScroller({ usePublisher: usePublisher$2, useEmitterValue: useEmitterValue$2, useEmitter: useEmitter$2 });\nconst Virtuoso = List;\nconst GroupedVirtuoso = List;\nconst INITIAL_GRID_STATE = {\n  items: [],\n  offsetBottom: 0,\n  offsetTop: 0,\n  top: 0,\n  bottom: 0,\n  itemHeight: 0,\n  itemWidth: 0\n};\nconst PROBE_GRID_STATE = {\n  items: [{ index: 0 }],\n  offsetBottom: 0,\n  offsetTop: 0,\n  top: 0,\n  bottom: 0,\n  itemHeight: 0,\n  itemWidth: 0\n};\nconst { round, ceil, floor, min, max } = Math;\nfunction buildProbeGridState(items) {\n  return {\n    ...PROBE_GRID_STATE,\n    items\n  };\n}\nfunction buildItems(startIndex, endIndex, data) {\n  return Array.from({ length: endIndex - startIndex + 1 }).map(\n    (_, i) => ({ index: i + startIndex, data: data == null ? void 0 : data[i + startIndex] })\n  );\n}\nfunction gapComparator(prev, next) {\n  return prev && prev.column === next.column && prev.row === next.row;\n}\nfunction dimensionComparator(prev, next) {\n  return prev && prev.width === next.width && prev.height === next.height;\n}\nconst gridSystem = /* @__PURE__ */ system(\n  ([\n    { overscan, visibleRange, listBoundary },\n    { scrollTop, viewportHeight, scrollBy, scrollTo, smoothScrollTargetReached, scrollContainerState, footerHeight, headerHeight },\n    stateFlags,\n    scrollSeek,\n    { propsReady, didMount },\n    { windowViewportRect, windowScrollTo, useWindowScroll, customScrollParent, windowScrollContainerState },\n    log\n  ]) => {\n    const totalCount = statefulStream(0);\n    const initialItemCount = statefulStream(0);\n    const gridState = statefulStream(INITIAL_GRID_STATE);\n    const viewportDimensions = statefulStream({ height: 0, width: 0 });\n    const itemDimensions = statefulStream({ height: 0, width: 0 });\n    const scrollToIndex = stream();\n    const scrollHeight = stream();\n    const deviation = statefulStream(0);\n    const data = statefulStream(void 0);\n    const gap = statefulStream({ row: 0, column: 0 });\n    connect(\n      pipe(\n        combineLatest(didMount, initialItemCount, data),\n        filter(([, count]) => count !== 0),\n        map(([, count, data2]) => {\n          return {\n            items: buildItems(0, count - 1, data2),\n            top: 0,\n            bottom: 0,\n            offsetBottom: 0,\n            offsetTop: 0,\n            itemHeight: 0,\n            itemWidth: 0\n          };\n        })\n      ),\n      gridState\n    );\n    connect(\n      pipe(\n        combineLatest(\n          duc(totalCount),\n          visibleRange,\n          duc(gap, gapComparator),\n          duc(itemDimensions, dimensionComparator),\n          duc(viewportDimensions, dimensionComparator),\n          data\n        ),\n        map(([totalCount2, [startOffset, endOffset], gap2, item, viewport, data2]) => {\n          const { row: rowGap, column: columnGap } = gap2;\n          const { height: itemHeight, width: itemWidth } = item;\n          const { width: viewportWidth } = viewport;\n          if (totalCount2 === 0 || viewportWidth === 0) {\n            return INITIAL_GRID_STATE;\n          }\n          if (itemWidth === 0) {\n            return buildProbeGridState(buildItems(0, 0, data2));\n          }\n          const perRow = itemsPerRow(viewportWidth, itemWidth, columnGap);\n          let startIndex = perRow * floor((startOffset + rowGap) / (itemHeight + rowGap));\n          let endIndex = perRow * ceil((endOffset + rowGap) / (itemHeight + rowGap)) - 1;\n          endIndex = min(totalCount2 - 1, max(endIndex, perRow - 1));\n          startIndex = min(endIndex, max(0, startIndex));\n          const items = buildItems(startIndex, endIndex, data2);\n          const { top, bottom } = gridLayout(viewport, gap2, item, items);\n          const rowCount = ceil(totalCount2 / perRow);\n          const totalHeight = rowCount * itemHeight + (rowCount - 1) * rowGap;\n          const offsetBottom = totalHeight - bottom;\n          return { items, offsetTop: top, offsetBottom, top, bottom, itemHeight, itemWidth };\n        })\n      ),\n      gridState\n    );\n    connect(\n      pipe(\n        data,\n        filter((data2) => data2 !== void 0),\n        map((data2) => data2.length)\n      ),\n      totalCount\n    );\n    connect(\n      pipe(\n        viewportDimensions,\n        map(({ height }) => height)\n      ),\n      viewportHeight\n    );\n    connect(\n      pipe(\n        combineLatest(viewportDimensions, itemDimensions, gridState, gap),\n        map(([viewportDimensions2, item, { items }, gap2]) => {\n          const { top, bottom } = gridLayout(viewportDimensions2, gap2, item, items);\n          return [top, bottom];\n        }),\n        distinctUntilChanged(tupleComparator)\n      ),\n      listBoundary\n    );\n    const endReached = streamFromEmitter(\n      pipe(\n        duc(gridState),\n        filter(({ items }) => items.length > 0),\n        withLatestFrom(totalCount),\n        filter(([{ items }, totalCount2]) => items[items.length - 1].index === totalCount2 - 1),\n        map(([, totalCount2]) => totalCount2 - 1),\n        distinctUntilChanged()\n      )\n    );\n    const startReached = streamFromEmitter(\n      pipe(\n        duc(gridState),\n        filter(({ items }) => {\n          return items.length > 0 && items[0].index === 0;\n        }),\n        mapTo(0),\n        distinctUntilChanged()\n      )\n    );\n    const rangeChanged = streamFromEmitter(\n      pipe(\n        duc(gridState),\n        filter(({ items }) => items.length > 0),\n        map(({ items }) => {\n          return {\n            startIndex: items[0].index,\n            endIndex: items[items.length - 1].index\n          };\n        }),\n        distinctUntilChanged(rangeComparator)\n      )\n    );\n    connect(rangeChanged, scrollSeek.scrollSeekRangeChanged);\n    connect(\n      pipe(\n        scrollToIndex,\n        withLatestFrom(viewportDimensions, itemDimensions, totalCount, gap),\n        map(([location, viewport, item, totalCount2, gap2]) => {\n          const normalLocation = normalizeIndexLocation(location);\n          const { align, behavior, offset } = normalLocation;\n          let index = normalLocation.index;\n          if (index === \"LAST\") {\n            index = totalCount2 - 1;\n          }\n          index = max(0, index, min(totalCount2 - 1, index));\n          let top = itemTop(viewport, gap2, item, index);\n          if (align === \"end\") {\n            top = round(top - viewport.height + item.height);\n          } else if (align === \"center\") {\n            top = round(top - viewport.height / 2 + item.height / 2);\n          }\n          if (offset) {\n            top += offset;\n          }\n          return { top, behavior };\n        })\n      ),\n      scrollTo\n    );\n    const totalListHeight = statefulStreamFromEmitter(\n      pipe(\n        gridState,\n        map((gridState2) => {\n          return gridState2.offsetBottom + gridState2.bottom;\n        })\n      ),\n      0\n    );\n    connect(\n      pipe(\n        windowViewportRect,\n        map((viewportInfo) => ({ width: viewportInfo.visibleWidth, height: viewportInfo.visibleHeight }))\n      ),\n      viewportDimensions\n    );\n    return {\n      data,\n      totalCount,\n      viewportDimensions,\n      itemDimensions,\n      scrollTop,\n      scrollHeight,\n      overscan,\n      scrollBy,\n      scrollTo,\n      scrollToIndex,\n      smoothScrollTargetReached,\n      windowViewportRect,\n      windowScrollTo,\n      useWindowScroll,\n      customScrollParent,\n      windowScrollContainerState,\n      deviation,\n      scrollContainerState,\n      footerHeight,\n      headerHeight,\n      initialItemCount,\n      gap,\n      ...scrollSeek,\n      gridState,\n      totalListHeight,\n      ...stateFlags,\n      startReached,\n      endReached,\n      rangeChanged,\n      propsReady,\n      ...log\n    };\n  },\n  tup(sizeRangeSystem, domIOSystem, stateFlagsSystem, scrollSeekSystem, propsReadySystem, windowScrollerSystem, loggerSystem)\n);\nfunction gridLayout(viewport, gap, item, items) {\n  const { height: itemHeight } = item;\n  if (itemHeight === void 0 || items.length === 0) {\n    return { top: 0, bottom: 0 };\n  }\n  const top = itemTop(viewport, gap, item, items[0].index);\n  const bottom = itemTop(viewport, gap, item, items[items.length - 1].index) + itemHeight;\n  return { top, bottom };\n}\nfunction itemTop(viewport, gap, item, index) {\n  const perRow = itemsPerRow(viewport.width, item.width, gap.column);\n  const rowCount = floor(index / perRow);\n  const top = rowCount * item.height + max(0, rowCount - 1) * gap.row;\n  return top > 0 ? top + gap.row : top;\n}\nfunction itemsPerRow(viewportWidth, itemWidth, gap) {\n  return max(1, floor((viewportWidth + gap) / (itemWidth + gap)));\n}\nconst gridComponentPropsSystem = /* @__PURE__ */ system(() => {\n  const itemContent = statefulStream((index) => `Item ${index}`);\n  const components = statefulStream({});\n  const context = statefulStream(null);\n  const itemClassName = statefulStream(\"virtuoso-grid-item\");\n  const listClassName = statefulStream(\"virtuoso-grid-list\");\n  const computeItemKey = statefulStream(identity);\n  const headerFooterTag = statefulStream(\"div\");\n  const scrollerRef = statefulStream(noop);\n  const distinctProp = (propName, defaultValue = null) => {\n    return statefulStreamFromEmitter(\n      pipe(\n        components,\n        map((components2) => components2[propName]),\n        distinctUntilChanged()\n      ),\n      defaultValue\n    );\n  };\n  return {\n    context,\n    itemContent,\n    components,\n    computeItemKey,\n    itemClassName,\n    listClassName,\n    headerFooterTag,\n    scrollerRef,\n    FooterComponent: distinctProp(\"Footer\"),\n    HeaderComponent: distinctProp(\"Header\"),\n    ListComponent: distinctProp(\"List\", \"div\"),\n    ItemComponent: distinctProp(\"Item\", \"div\"),\n    ScrollerComponent: distinctProp(\"Scroller\", \"div\"),\n    ScrollSeekPlaceholder: distinctProp(\"ScrollSeekPlaceholder\", \"div\")\n  };\n});\nconst combinedSystem$1 = /* @__PURE__ */ system(([gridSystem2, gridComponentPropsSystem2]) => {\n  return { ...gridSystem2, ...gridComponentPropsSystem2 };\n}, tup(gridSystem, gridComponentPropsSystem));\nconst GridItems = /* @__PURE__ */ React.memo(function GridItems2() {\n  const gridState = useEmitterValue$1(\"gridState\");\n  const listClassName = useEmitterValue$1(\"listClassName\");\n  const itemClassName = useEmitterValue$1(\"itemClassName\");\n  const itemContent = useEmitterValue$1(\"itemContent\");\n  const computeItemKey = useEmitterValue$1(\"computeItemKey\");\n  const isSeeking = useEmitterValue$1(\"isSeeking\");\n  const scrollHeightCallback = usePublisher$1(\"scrollHeight\");\n  const ItemComponent = useEmitterValue$1(\"ItemComponent\");\n  const ListComponent = useEmitterValue$1(\"ListComponent\");\n  const ScrollSeekPlaceholder = useEmitterValue$1(\"ScrollSeekPlaceholder\");\n  const context = useEmitterValue$1(\"context\");\n  const itemDimensions = usePublisher$1(\"itemDimensions\");\n  const gridGap = usePublisher$1(\"gap\");\n  const log = useEmitterValue$1(\"log\");\n  const listRef = useSize((el) => {\n    const scrollHeight = el.parentElement.parentElement.scrollHeight;\n    scrollHeightCallback(scrollHeight);\n    const firstItem = el.firstChild;\n    if (firstItem) {\n      itemDimensions(firstItem.getBoundingClientRect());\n    }\n    gridGap({\n      row: resolveGapValue(\"row-gap\", getComputedStyle(el).rowGap, log),\n      column: resolveGapValue(\"column-gap\", getComputedStyle(el).columnGap, log)\n    });\n  });\n  return React.createElement(\n    ListComponent,\n    {\n      ref: listRef,\n      className: listClassName,\n      ...contextPropIfNotDomElement(ListComponent, context),\n      style: { paddingTop: gridState.offsetTop, paddingBottom: gridState.offsetBottom },\n      \"data-test-id\": \"virtuoso-item-list\"\n    },\n    gridState.items.map((item) => {\n      const key = computeItemKey(item.index, item.data, context);\n      return isSeeking ? React.createElement(ScrollSeekPlaceholder, {\n        key,\n        ...contextPropIfNotDomElement(ScrollSeekPlaceholder, context),\n        index: item.index,\n        height: gridState.itemHeight,\n        width: gridState.itemWidth\n      }) : React.createElement(\n        ItemComponent,\n        { ...contextPropIfNotDomElement(ItemComponent, context), className: itemClassName, \"data-index\": item.index, key },\n        itemContent(item.index, item.data, context)\n      );\n    })\n  );\n});\nconst Header = React.memo(function VirtuosoHeader2() {\n  const Header2 = useEmitterValue$1(\"HeaderComponent\");\n  const headerHeight = usePublisher$1(\"headerHeight\");\n  const headerFooterTag = useEmitterValue$1(\"headerFooterTag\");\n  const ref = useSize((el) => headerHeight(correctItemSize(el, \"height\")));\n  const context = useEmitterValue$1(\"context\");\n  return Header2 ? React.createElement(headerFooterTag, { ref }, React.createElement(Header2, contextPropIfNotDomElement(Header2, context))) : null;\n});\nconst Footer = React.memo(function VirtuosoGridFooter() {\n  const Footer2 = useEmitterValue$1(\"FooterComponent\");\n  const footerHeight = usePublisher$1(\"footerHeight\");\n  const headerFooterTag = useEmitterValue$1(\"headerFooterTag\");\n  const ref = useSize((el) => footerHeight(correctItemSize(el, \"height\")));\n  const context = useEmitterValue$1(\"context\");\n  return Footer2 ? React.createElement(headerFooterTag, { ref }, React.createElement(Footer2, contextPropIfNotDomElement(Footer2, context))) : null;\n});\nconst Viewport$1 = ({ children }) => {\n  const ctx = React.useContext(VirtuosoGridMockContext);\n  const itemDimensions = usePublisher$1(\"itemDimensions\");\n  const viewportDimensions = usePublisher$1(\"viewportDimensions\");\n  const viewportRef = useSize((el) => {\n    viewportDimensions(el.getBoundingClientRect());\n  });\n  React.useEffect(() => {\n    if (ctx) {\n      viewportDimensions({ height: ctx.viewportHeight, width: ctx.viewportWidth });\n      itemDimensions({ height: ctx.itemHeight, width: ctx.itemWidth });\n    }\n  }, [ctx, viewportDimensions, itemDimensions]);\n  return /* @__PURE__ */ React.createElement(\"div\", { style: viewportStyle, ref: viewportRef }, children);\n};\nconst WindowViewport$1 = ({ children }) => {\n  const ctx = React.useContext(VirtuosoGridMockContext);\n  const windowViewportRect = usePublisher$1(\"windowViewportRect\");\n  const itemDimensions = usePublisher$1(\"itemDimensions\");\n  const customScrollParent = useEmitterValue$1(\"customScrollParent\");\n  const viewportRef = useWindowViewportRectRef(windowViewportRect, customScrollParent);\n  React.useEffect(() => {\n    if (ctx) {\n      itemDimensions({ height: ctx.itemHeight, width: ctx.itemWidth });\n      windowViewportRect({ offsetTop: 0, visibleHeight: ctx.viewportHeight, visibleWidth: ctx.viewportWidth });\n    }\n  }, [ctx, windowViewportRect, itemDimensions]);\n  return /* @__PURE__ */ React.createElement(\"div\", { ref: viewportRef, style: viewportStyle }, children);\n};\nconst GridRoot = /* @__PURE__ */ React.memo(function GridRoot2({ ...props }) {\n  const useWindowScroll = useEmitterValue$1(\"useWindowScroll\");\n  const customScrollParent = useEmitterValue$1(\"customScrollParent\");\n  const TheScroller = customScrollParent || useWindowScroll ? WindowScroller$1 : Scroller$1;\n  const TheViewport = customScrollParent || useWindowScroll ? WindowViewport$1 : Viewport$1;\n  return /* @__PURE__ */ React.createElement(TheScroller, { ...props }, /* @__PURE__ */ React.createElement(TheViewport, null, /* @__PURE__ */ React.createElement(Header, null), /* @__PURE__ */ React.createElement(GridItems, null), /* @__PURE__ */ React.createElement(Footer, null)));\n});\nconst {\n  Component: Grid,\n  usePublisher: usePublisher$1,\n  useEmitterValue: useEmitterValue$1,\n  useEmitter: useEmitter$1\n} = /* @__PURE__ */ systemToComponent(\n  combinedSystem$1,\n  {\n    optional: {\n      context: \"context\",\n      totalCount: \"totalCount\",\n      overscan: \"overscan\",\n      itemContent: \"itemContent\",\n      components: \"components\",\n      computeItemKey: \"computeItemKey\",\n      data: \"data\",\n      initialItemCount: \"initialItemCount\",\n      scrollSeekConfiguration: \"scrollSeekConfiguration\",\n      headerFooterTag: \"headerFooterTag\",\n      listClassName: \"listClassName\",\n      itemClassName: \"itemClassName\",\n      useWindowScroll: \"useWindowScroll\",\n      customScrollParent: \"customScrollParent\",\n      scrollerRef: \"scrollerRef\"\n    },\n    methods: {\n      scrollTo: \"scrollTo\",\n      scrollBy: \"scrollBy\",\n      scrollToIndex: \"scrollToIndex\"\n    },\n    events: {\n      isScrolling: \"isScrolling\",\n      endReached: \"endReached\",\n      startReached: \"startReached\",\n      rangeChanged: \"rangeChanged\",\n      atBottomStateChange: \"atBottomStateChange\",\n      atTopStateChange: \"atTopStateChange\"\n    }\n  },\n  GridRoot\n);\nconst Scroller$1 = /* @__PURE__ */ buildScroller({ usePublisher: usePublisher$1, useEmitterValue: useEmitterValue$1, useEmitter: useEmitter$1 });\nconst WindowScroller$1 = /* @__PURE__ */ buildWindowScroller({ usePublisher: usePublisher$1, useEmitterValue: useEmitterValue$1, useEmitter: useEmitter$1 });\nfunction resolveGapValue(property, value, log) {\n  if (value !== \"normal\" && !(value == null ? void 0 : value.endsWith(\"px\"))) {\n    log(`${property} was not resolved to pixel value correctly`, value, LogLevel.WARN);\n  }\n  if (value === \"normal\") {\n    return 0;\n  }\n  return parseInt(value ?? \"0\", 10);\n}\nconst VirtuosoGrid = Grid;\nconst tableComponentPropsSystem = /* @__PURE__ */ system(() => {\n  const itemContent = statefulStream((index) => /* @__PURE__ */ React.createElement(\"td\", null, \"Item $\", index));\n  const context = statefulStream(null);\n  const fixedHeaderContent = statefulStream(null);\n  const fixedFooterContent = statefulStream(null);\n  const components = statefulStream({});\n  const computeItemKey = statefulStream(identity);\n  const scrollerRef = statefulStream(noop);\n  const distinctProp = (propName, defaultValue = null) => {\n    return statefulStreamFromEmitter(\n      pipe(\n        components,\n        map((components2) => components2[propName]),\n        distinctUntilChanged()\n      ),\n      defaultValue\n    );\n  };\n  return {\n    context,\n    itemContent,\n    fixedHeaderContent,\n    fixedFooterContent,\n    components,\n    computeItemKey,\n    scrollerRef,\n    TableComponent: distinctProp(\"Table\", \"table\"),\n    TableHeadComponent: distinctProp(\"TableHead\", \"thead\"),\n    TableFooterComponent: distinctProp(\"TableFoot\", \"tfoot\"),\n    TableBodyComponent: distinctProp(\"TableBody\", \"tbody\"),\n    TableRowComponent: distinctProp(\"TableRow\", \"tr\"),\n    ScrollerComponent: distinctProp(\"Scroller\", \"div\"),\n    EmptyPlaceholder: distinctProp(\"EmptyPlaceholder\"),\n    ScrollSeekPlaceholder: distinctProp(\"ScrollSeekPlaceholder\"),\n    FillerRow: distinctProp(\"FillerRow\")\n  };\n});\nconst combinedSystem = /* @__PURE__ */ system(([listSystem2, propsSystem]) => {\n  return { ...listSystem2, ...propsSystem };\n}, tup(listSystem, tableComponentPropsSystem));\nconst DefaultScrollSeekPlaceholder = ({ height }) => /* @__PURE__ */ React.createElement(\"tr\", null, /* @__PURE__ */ React.createElement(\"td\", { style: { height } }));\nconst DefaultFillerRow = ({ height }) => /* @__PURE__ */ React.createElement(\"tr\", null, /* @__PURE__ */ React.createElement(\"td\", { style: { height, padding: 0, border: 0 } }));\nconst Items = /* @__PURE__ */ React.memo(function VirtuosoItems2() {\n  const listState = useEmitterValue(\"listState\");\n  const sizeRanges = usePublisher(\"sizeRanges\");\n  const useWindowScroll = useEmitterValue(\"useWindowScroll\");\n  const customScrollParent = useEmitterValue(\"customScrollParent\");\n  const windowScrollContainerStateCallback = usePublisher(\"windowScrollContainerState\");\n  const _scrollContainerStateCallback = usePublisher(\"scrollContainerState\");\n  const scrollContainerStateCallback = customScrollParent || useWindowScroll ? windowScrollContainerStateCallback : _scrollContainerStateCallback;\n  const itemContent = useEmitterValue(\"itemContent\");\n  const trackItemSizes = useEmitterValue(\"trackItemSizes\");\n  const itemSize = useEmitterValue(\"itemSize\");\n  const log = useEmitterValue(\"log\");\n  const { callbackRef, ref } = useChangedListContentsSizes(\n    sizeRanges,\n    itemSize,\n    trackItemSizes,\n    scrollContainerStateCallback,\n    log,\n    void 0,\n    customScrollParent\n  );\n  const [deviation, setDeviation] = React.useState(0);\n  useEmitter(\"deviation\", (value) => {\n    if (deviation !== value) {\n      ref.current.style.marginTop = `${value}px`;\n      setDeviation(value);\n    }\n  });\n  const EmptyPlaceholder = useEmitterValue(\"EmptyPlaceholder\");\n  const ScrollSeekPlaceholder = useEmitterValue(\"ScrollSeekPlaceholder\") || DefaultScrollSeekPlaceholder;\n  const FillerRow = useEmitterValue(\"FillerRow\") || DefaultFillerRow;\n  const TableBodyComponent = useEmitterValue(\"TableBodyComponent\");\n  const TableRowComponent = useEmitterValue(\"TableRowComponent\");\n  const computeItemKey = useEmitterValue(\"computeItemKey\");\n  const isSeeking = useEmitterValue(\"isSeeking\");\n  const paddingTopAddition = useEmitterValue(\"paddingTopAddition\");\n  const firstItemIndex = useEmitterValue(\"firstItemIndex\");\n  const statefulTotalCount = useEmitterValue(\"statefulTotalCount\");\n  const context = useEmitterValue(\"context\");\n  if (statefulTotalCount === 0 && EmptyPlaceholder) {\n    return React.createElement(EmptyPlaceholder, contextPropIfNotDomElement(EmptyPlaceholder, context));\n  }\n  const paddingTop = listState.offsetTop + paddingTopAddition + deviation;\n  const paddingBottom = listState.offsetBottom;\n  const paddingTopEl = paddingTop > 0 ? /* @__PURE__ */ React.createElement(FillerRow, { height: paddingTop, key: \"padding-top\", context }) : null;\n  const paddingBottomEl = paddingBottom > 0 ? /* @__PURE__ */ React.createElement(FillerRow, { height: paddingBottom, key: \"padding-bottom\", context }) : null;\n  const items = listState.items.map((item) => {\n    const index = item.originalIndex;\n    const key = computeItemKey(index + firstItemIndex, item.data, context);\n    if (isSeeking) {\n      return React.createElement(ScrollSeekPlaceholder, {\n        ...contextPropIfNotDomElement(ScrollSeekPlaceholder, context),\n        key,\n        index: item.index,\n        height: item.size,\n        type: item.type || \"item\"\n      });\n    }\n    return React.createElement(\n      TableRowComponent,\n      {\n        ...contextPropIfNotDomElement(TableRowComponent, context),\n        key,\n        \"data-index\": index,\n        \"data-known-size\": item.size,\n        \"data-item-index\": item.index,\n        item: item.data,\n        style: { overflowAnchor: \"none\" }\n      },\n      itemContent(item.index, item.data, context)\n    );\n  });\n  return React.createElement(\n    TableBodyComponent,\n    { ref: callbackRef, \"data-test-id\": \"virtuoso-item-list\", ...contextPropIfNotDomElement(TableBodyComponent, context) },\n    [paddingTopEl, ...items, paddingBottomEl]\n  );\n});\nconst Viewport = ({ children }) => {\n  const ctx = React.useContext(VirtuosoMockContext);\n  const viewportHeight = usePublisher(\"viewportHeight\");\n  const fixedItemHeight = usePublisher(\"fixedItemHeight\");\n  const viewportRef = useSize(compose(viewportHeight, (el) => correctItemSize(el, \"height\")));\n  React.useEffect(() => {\n    if (ctx) {\n      viewportHeight(ctx.viewportHeight);\n      fixedItemHeight(ctx.itemHeight);\n    }\n  }, [ctx, viewportHeight, fixedItemHeight]);\n  return /* @__PURE__ */ React.createElement(\"div\", { style: viewportStyle, ref: viewportRef, \"data-viewport-type\": \"element\" }, children);\n};\nconst WindowViewport = ({ children }) => {\n  const ctx = React.useContext(VirtuosoMockContext);\n  const windowViewportRect = usePublisher(\"windowViewportRect\");\n  const fixedItemHeight = usePublisher(\"fixedItemHeight\");\n  const customScrollParent = useEmitterValue(\"customScrollParent\");\n  const viewportRef = useWindowViewportRectRef(windowViewportRect, customScrollParent);\n  React.useEffect(() => {\n    if (ctx) {\n      fixedItemHeight(ctx.itemHeight);\n      windowViewportRect({ offsetTop: 0, visibleHeight: ctx.viewportHeight, visibleWidth: 100 });\n    }\n  }, [ctx, windowViewportRect, fixedItemHeight]);\n  return /* @__PURE__ */ React.createElement(\"div\", { ref: viewportRef, style: viewportStyle, \"data-viewport-type\": \"window\" }, children);\n};\nconst TableRoot = /* @__PURE__ */ React.memo(function TableVirtuosoRoot(props) {\n  const useWindowScroll = useEmitterValue(\"useWindowScroll\");\n  const customScrollParent = useEmitterValue(\"customScrollParent\");\n  const fixedHeaderHeight = usePublisher(\"fixedHeaderHeight\");\n  const fixedFooterHeight = usePublisher(\"fixedFooterHeight\");\n  const fixedHeaderContent = useEmitterValue(\"fixedHeaderContent\");\n  const fixedFooterContent = useEmitterValue(\"fixedFooterContent\");\n  const context = useEmitterValue(\"context\");\n  const theadRef = useSize(compose(fixedHeaderHeight, (el) => correctItemSize(el, \"height\")));\n  const tfootRef = useSize(compose(fixedFooterHeight, (el) => correctItemSize(el, \"height\")));\n  const TheScroller = customScrollParent || useWindowScroll ? WindowScroller : Scroller;\n  const TheViewport = customScrollParent || useWindowScroll ? WindowViewport : Viewport;\n  const TheTable = useEmitterValue(\"TableComponent\");\n  const TheTHead = useEmitterValue(\"TableHeadComponent\");\n  const TheTFoot = useEmitterValue(\"TableFooterComponent\");\n  const theHead = fixedHeaderContent ? React.createElement(\n    TheTHead,\n    {\n      key: \"TableHead\",\n      style: { zIndex: 1, position: \"sticky\", top: 0 },\n      ref: theadRef,\n      ...contextPropIfNotDomElement(TheTHead, context)\n    },\n    fixedHeaderContent()\n  ) : null;\n  const theFoot = fixedFooterContent ? React.createElement(\n    TheTFoot,\n    {\n      key: \"TableFoot\",\n      style: { zIndex: 1, position: \"sticky\", bottom: 0 },\n      ref: tfootRef,\n      ...contextPropIfNotDomElement(TheTFoot, context)\n    },\n    fixedFooterContent()\n  ) : null;\n  return /* @__PURE__ */ React.createElement(TheScroller, { ...props }, /* @__PURE__ */ React.createElement(TheViewport, null, React.createElement(TheTable, { style: { borderSpacing: 0 }, ...contextPropIfNotDomElement(TheTable, context) }, [\n    theHead,\n    /* @__PURE__ */ React.createElement(Items, { key: \"TableBody\" }),\n    theFoot\n  ])));\n});\nconst {\n  Component: Table,\n  usePublisher,\n  useEmitterValue,\n  useEmitter\n} = /* @__PURE__ */ systemToComponent(\n  combinedSystem,\n  {\n    required: {},\n    optional: {\n      context: \"context\",\n      followOutput: \"followOutput\",\n      firstItemIndex: \"firstItemIndex\",\n      itemContent: \"itemContent\",\n      fixedHeaderContent: \"fixedHeaderContent\",\n      fixedFooterContent: \"fixedFooterContent\",\n      overscan: \"overscan\",\n      increaseViewportBy: \"increaseViewportBy\",\n      totalCount: \"totalCount\",\n      topItemCount: \"topItemCount\",\n      initialTopMostItemIndex: \"initialTopMostItemIndex\",\n      components: \"components\",\n      groupCounts: \"groupCounts\",\n      atBottomThreshold: \"atBottomThreshold\",\n      atTopThreshold: \"atTopThreshold\",\n      computeItemKey: \"computeItemKey\",\n      defaultItemHeight: \"defaultItemHeight\",\n      fixedItemHeight: \"fixedItemHeight\",\n      itemSize: \"itemSize\",\n      scrollSeekConfiguration: \"scrollSeekConfiguration\",\n      data: \"data\",\n      initialItemCount: \"initialItemCount\",\n      initialScrollTop: \"initialScrollTop\",\n      alignToBottom: \"alignToBottom\",\n      useWindowScroll: \"useWindowScroll\",\n      customScrollParent: \"customScrollParent\",\n      scrollerRef: \"scrollerRef\",\n      logLevel: \"logLevel\"\n    },\n    methods: {\n      scrollToIndex: \"scrollToIndex\",\n      scrollIntoView: \"scrollIntoView\",\n      scrollTo: \"scrollTo\",\n      scrollBy: \"scrollBy\"\n    },\n    events: {\n      isScrolling: \"isScrolling\",\n      endReached: \"endReached\",\n      startReached: \"startReached\",\n      rangeChanged: \"rangeChanged\",\n      atBottomStateChange: \"atBottomStateChange\",\n      atTopStateChange: \"atTopStateChange\",\n      totalListHeightChanged: \"totalListHeightChanged\",\n      itemsRendered: \"itemsRendered\",\n      groupIndices: \"groupIndices\"\n    }\n  },\n  TableRoot\n);\nconst Scroller = /* @__PURE__ */ buildScroller({ usePublisher, useEmitterValue, useEmitter });\nconst WindowScroller = /* @__PURE__ */ buildWindowScroller({ usePublisher, useEmitterValue, useEmitter });\nconst TableVirtuoso = Table;\nexport {\n  GroupedVirtuoso,\n  LogLevel,\n  TableVirtuoso,\n  Virtuoso,\n  VirtuosoGrid,\n  VirtuosoGridMockContext,\n  VirtuosoMockContext\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}